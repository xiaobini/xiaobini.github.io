<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FreeRTOS快速入门（二）</title>
      <link href="/2023/09/24/FreeRTOS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/09/24/FreeRTOS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h1><p>同步与互斥主要是指在使用同一个资源的时候，一次只能由一个任务使用，后面的任务如果也想使用这个资源的时候只有等到前面的任务释放了这个资源才能使用。</p><p>常见的同步互斥的实现有：队列、任务通知、信号量、互斥量、事件组。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的使用"><a href="#队列的使用" class="headerlink" title="队列的使用"></a>队列的使用</h3><p>如果队列中没有数据，那么在读取这个队列的时候会进入到阻塞状态，直到队列中有数据为止。所以两个或以上的任务在抢夺相同资源的时候，可以将这个资源放入到队列中，如果拿到这个资源的任务先将队列清空，其他的任务等待这个资源直到这个任务完成的时候在将这个资源放入队列。</p><p>创建队列函数<code>QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )  </code></p><blockquote><p>uxQueueLength:指队列的长度</p><p>uxTtemSize:队列数据每个数据的大小</p><p>返回值：成功返回队列句柄，失败返回0</p></blockquote><p>队列的本质是一个环形缓冲区，在队列的内部有几个参数比较重要。</p><p><strong>队列参数：</strong></p><p><strong>1. pchead 指向buf首地址，指针的地址不会随着读取的位置变化而变化</strong></p><p><strong>2.pcreadfrom 上一次读地址的位置</strong></p><p><strong>3.pcwrite 上一次写的地址，默认情况下到队尾</strong></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle = xQueueCreate(<span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//创建一个存放1nt大小的队列</span></span><br></pre></td></tr></table></figure><p>在创建队列的时候，也可以传入结构体。</p><h3 id="队列写操作"><a href="#队列写操作" class="headerlink" title="队列写操作"></a>队列写操作</h3><p>写入数据时会拷贝itemsize大小的空间然后调整pcwirte指针的地址pcwrite +&#x3D; itemsize。如果队列写满的时候可以传入一个等待时间，如果不等待则立刻报错。在等待时间内会将任务放入xTaskwaitingTosend的队列，在等待时间后如果队列还是满的则报错。写满数据后pcwrite会在队列尾部跳转到头部。</p><p>写队列函数<code>BaseType_t xQueueSend(QueueHandle_t xQueue,const void *pvItemToQueue,TickType_t xTicksToWait)</code></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>xQueue</td><td>队列句柄</td></tr><tr><td>pvItemToQueue</td><td>写入队列的数据指针，</td></tr><tr><td>xTicksToWait</td><td>如果队列满的时候可以阻塞多长时间，如果传入portMAX_DELAY则表示等待可以等待的最长时间</td></tr></tbody></table><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xQueueSend(QueueHandle,&amp;a,portMAX_DELAY);  <span class="comment">// 传入变量a的地址到队列</span></span><br></pre></td></tr></table></figure><h3 id="队列读操作"><a href="#队列读操作" class="headerlink" title="队列读操作"></a>队列读操作</h3><p>读操作会将读到的数据放入buf中，如果没有数据会等待一段时间后报错，由于pcreadfrom指向的时上一次读的位置，所以在下一次读的时候pcreadfrom+&#x3D;itemsize，如果pcreadfrom到达列尾则下一次读时返回头部。</p><p>读队列函数：<code>BaseType_t xQueueReceive( QueueHandle_t xQueue,void * const pvBuffer,TickType_t xTicksToWait );  </code></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>xQueue</td><td>欲读取的队列的队列句柄</td></tr><tr><td>pvBuffer</td><td>将读到的数据放入到buffer中</td></tr><tr><td>xTicksToWait</td><td>如果队列为空的时候可以阻塞多长时间，如果传入portMAX_DELAY则表示等待可以等待的最长时间</td></tr></tbody></table><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xQueueReceive(QueueHandle,&amp;val,portMAX_DELAY);<span class="comment">//读取QueueHandle句柄的队列，并且将读取到的数据放入到val中，延迟时间portMAX_DELAY</span></span><br></pre></td></tr></table></figure><h3 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建两个任务，并且初始化传入一个默认的任务。task1和task2争抢队列资源，没有抢到的任务进行等到，抢到的任务获取队列中的数值并且打印该资源的值。执行完毕之后在完队列中传入一个数值。以便让其他任务调用。</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> rev;</span><br><span class="line"><span class="type">int</span> val =<span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1=<span class="number">1</span>;</span><br><span class="line">flag2=<span class="number">0</span>;</span><br><span class="line">xQueueReceive(QueueHandle,&amp;rev,portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task1:%d\n&quot;</span>,rev);</span><br><span class="line">xQueueSend( QueueHandle,&amp;val,portMAX_DELAY);</span><br><span class="line">vTaskResume(Task2Handle);</span><br><span class="line">vTaskResume(Task3Handle);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">Task2</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="type">int</span> val2 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1=<span class="number">0</span>;</span><br><span class="line">flag2=<span class="number">1</span>;</span><br><span class="line">xQueueReceive(QueueHandle,&amp;val,portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task2:%d\n&quot;</span>,val);</span><br><span class="line">xQueueSend(QueueHandle,&amp;val2,portMAX_DELAY);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">prvSetupHardware();</span><br><span class="line">QueueHandle = xQueueCreate(<span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// 创建队列</span></span><br><span class="line"><span class="keyword">if</span>(QueueHandle == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;queue is not create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">50</span>,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;Task1Handle);  <span class="comment">// 创建两个任务</span></span><br><span class="line">xTaskCreate(Task2,<span class="string">&quot;task2&quot;</span>,<span class="number">50</span>,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;Task2Handle);</span><br><span class="line">xQueueSend(QueueHandle,&amp;a,portMAX_DELAY);  <span class="comment">// 往队列中放入一个资源</span></span><br><span class="line"><span class="comment">//xTaskCreate(Task3,&quot;task3&quot;,50,NULL,1,NULL);</span></span><br><span class="line"><span class="comment">/* Start the scheduler. */</span></span><br><span class="line"></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Will only get here if there was not enough heap space to create the</span></span><br><span class="line"><span class="comment">idle task. */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309252342015.png" alt="输出结果"></p><h2 id="队列集"><a href="#队列集" class="headerlink" title="队列集"></a>队列集</h2><p>队列集中存放了不同的队列，比如键盘队列以及鼠标队列等等都可以放入到统称为用户的队列中。创建队列集的大小为所存放队列大小的总和，如A队列大小为3、B为4、C为5，如果将ABC中放入队列集中那么队列集的大小至少为12。</p><h4 id="队列集的使用"><a href="#队列集的使用" class="headerlink" title="队列集的使用"></a>队列集的使用</h4><p>如果很多队列都放入到队列集中那么应该怎么判断获取的队列是哪一个队列呢？这种解决方法可以往队列中传入数据时候传入一个数据结构，数据结构中包含name等成员，获取到这个队列的时候可以读取队列结构体进行判断。</p><p>创建队列集：<code>QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength );  </code></p><p>参考FreeRTOS手册：</p><blockquote><p>uxEventQueueLength:Queue sets store events that occur on the queues and semaphores contained in the set. uxEventQueueLength specifies the maximum number of events that can be queued at once. To be absolutely certain that events are not lost uxEventQueueLength must be set to the sum of the lengths of the queues added to the set, where binary semaphores and mutexes have a length of 1, and counting semaphores have a length set by their maximum count value. For example:  If a queue set is to hold a queue of length 5, another queue of length 12, and a binary semaphore, then uxEventQueueLength should be set to (5 + 12 + 1), or 18.</p></blockquote><p>说明创建队列集的参数选取的是队列大小的总和。</p><p>返回值</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>NULL</td><td>队列集创建失败</td></tr><tr><td>队列集句柄</td><td>队列集创建成功</td></tr></tbody></table><h4 id="队列集添加队列"><a href="#队列集添加队列" class="headerlink" title="队列集添加队列"></a>队列集添加队列</h4><p> 队列集添加队列的函数：<code>BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,QueueSetHandle_t xQueueSet );  </code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xQueueOrSemaphore</td><td>要添加到队列集的队列或信号量的句柄</td></tr><tr><td>xQueueSet</td><td>队列集句柄</td></tr></tbody></table><h4 id="获取队列集中的队列"><a href="#获取队列集中的队列" class="headerlink" title="获取队列集中的队列"></a>获取队列集中的队列</h4><p>获取队列集队列的函数<code>QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,const TickType_t xTicksToWait );  </code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xQueueSet</td><td>传入队列集的句柄</td></tr><tr><td>xTicksToWait</td><td>如果队列集空的时候可以阻塞多长时间，如果传入portMAX_DELAY则表示等待可以等待的最长时间</td></tr></tbody></table><p>使用xQueueSelectFromSet返回获取到的队列句柄，如果想获取队列里面的内容则需要在使用xQueueReceive获取（跟队列的操作一样）。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>前面的队列以及队列集可以携带信息给到另外一个任务，这里介绍的信号量只能进行任务通知，比如A任务执行完任务之后放入信号量来通知B任务，“我执行完了，你现在可以执行了！”。</p><p>信号量的本质是队列，但是信号量只能够表示资源数量，无法传输数据，放入信号量计数值+1，取出信号量计数量-1。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309262234920.png"></p><p>信号量分为：计数型信号量、二进制型信号量。</p><p>计数型信号量</p><ol><li>初始化时可以是任何值</li><li>使用give可以一直向上计数</li></ol><p>二进制型信号量</p><ol><li>初始化的时候值为0</li><li>只有两个计数值0和1</li></ol><h3 id="创建信号量"><a href="#创建信号量" class="headerlink" title="创建信号量"></a>创建信号量</h3><p>创建二进制型信号量：<code>SemaphoreHandle_t xSemaphoreCreateBinary( void );  </code></p><p>创建计数型信号量：<code>SemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount);  </code> </p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>uxMaxCount</td><td>最大的计数数量</td></tr><tr><td>uxInitialCount</td><td>技术型信号量的初始值</td></tr></tbody></table><p>返回信号量句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphorecount = xSemaphoreCreateCounting(<span class="number">1</span>, <span class="number">0</span>);<span class="comment">// 创建计数型信号量，最大值为1，初始值为0，由此计数型信号量也可以模拟二进制型信号量</span></span><br></pre></td></tr></table></figure><h3 id="删除信号量"><a href="#删除信号量" class="headerlink" title="删除信号量"></a>删除信号量</h3><p>删除信号量函数：<code>void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );  </code></p><h3 id="信号量的使用（give-take）"><a href="#信号量的使用（give-take）" class="headerlink" title="信号量的使用（give&#x2F;take）"></a>信号量的使用（give&#x2F;take）</h3><p>放入信号量：<code>BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );  </code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>传入想要放入信号量的信号量句柄</td></tr></tbody></table><p>取出信号量：<code>BaseType_t xSemaphoreTake(SemaphoreHandle_t xSemaphore,TickType_t xTicksToWait);  </code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>想要取出信号量的信号量句柄</td></tr><tr><td>xTicksToWait</td><td>如果信号量的值为0则可以等待多长时间，如果传入portMAX_DELAY则表示等待可以等待的最长时间</td></tr></tbody></table><h3 id="综合示例-1"><a href="#综合示例-1" class="headerlink" title="综合示例"></a>综合示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t Task1Handle;</span><br><span class="line">TaskHandle_t Task2Handle;</span><br><span class="line">SemaphoreHandle_t SemaphoreHandle;</span><br><span class="line">QueueHandle_t semaphorecount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">xSemaphoreTake(SemaphoreHandle,  portMAX_DELAY);  <span class="comment">// 获取信号量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Task1:\n&quot;</span>);</span><br><span class="line">xSemaphoreGive(SemaphoreHandle);  <span class="comment">// 放入信号量</span></span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">Task2</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">xSemaphoreTake(SemaphoreHandle,  portMAX_DELAY);  <span class="comment">// 获取信号量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Task2:\n&quot;</span>);</span><br><span class="line">xSemaphoreGive(SemaphoreHandle);  <span class="comment">// 放入信号量</span></span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">prvSetupHardware();</span><br><span class="line">SemaphoreHandle = xSemaphoreCreateCounting(<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// 创建计数型信号量</span></span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">50</span>,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;Task1Handle);</span><br><span class="line">xTaskCreate(Task2,<span class="string">&quot;task2&quot;</span>,<span class="number">50</span>,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;Task2Handle);</span><br><span class="line">xSemaphoreGive(SemaphoreHandle);  <span class="comment">// 初始化放入一个值</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"><span class="comment">/* Will only get here if there was not enough heap space to create the</span></span><br><span class="line"><span class="comment">idle task. */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309262306480.png" alt="运行结果"></p><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>使用信号量的时候需要保证在A任务获得了资源后，B任务等待A执行结束放入资源。但是此时出现了一个C任务give信号量，导致在A任务执行期间B任务也开始执行导致与我们预想的AB只有一个执行不同。所以解决的措施是要谁上锁谁解锁，不能交由第三方。</p><p>在了解互斥量之前先了解两个概念：优先级继承、优先级反转。</p><h3 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h3><p>设想这样的一个场景，在使用信号量的时候假设有三个任务他们有着不同的优先级，A：1、B：2、C：3，并且A和C使用的是同一把锁A先执行获得锁。在A获取锁还么有释放的时候，B任务执行，由于B的优先级大于A 则B任务一直执行导致A任务跟优先级更高的C任务都不能够执行，这种优先级低的任务比优先级高的任务先执行的例子就是优先级反转。</p><h3 id="优先级继承"><a href="#优先级继承" class="headerlink" title="优先级继承"></a>优先级继承</h3><p><strong>解决优先级反转的问题就是使用优先级继承。</strong></p><p>优先级继承是指：低优先级获得锁的时候高优先级为了能够获得锁执行，<strong>临时</strong>将低优先级的任务优先级提升，等待低优先级的任务执行完成并且高优先级能够获得资源，那么低优先级的任务恢复到原来的优先级。</p><h3 id="互斥量的使用"><a href="#互斥量的使用" class="headerlink" title="互斥量的使用"></a>互斥量的使用</h3><p>互斥量跟信号量最大的不同点在于互斥量能够解决上述优先级反转的问题。获得互斥量的任务能够进行优先级继承。</p><p>互斥量的值与二进制信号量一样只有0跟1。</p><h4 id="创建互斥量"><a href="#创建互斥量" class="headerlink" title="创建互斥量"></a>创建互斥量</h4><p>创建互斥量的函数：<code>SemaphoreHandle_t xSemaphoreCreateMutex( void );  </code></p><p>创建互斥量返回信号句柄。</p><h4 id="互斥量的其他操作"><a href="#互斥量的其他操作" class="headerlink" title="互斥量的其他操作"></a>互斥量的其他操作</h4><p>互斥量在删除、Give和Take上与信号量一样。使用以下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;  <span class="comment">// 删除互斥量</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;  <span class="comment">// 放入互斥量</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(SemaphoreHandle_t xSemaphore,TickType_t xTicksToWait)</span>;  <span class="comment">// 获取互斥量</span></span><br></pre></td></tr></table></figure><h4 id="互斥量的使用案例"><a href="#互斥量的使用案例" class="headerlink" title="互斥量的使用案例"></a>互斥量的使用案例</h4><p>下面对使用互斥量和信号量进行一个对比：</p><p><strong>不使用互斥量的时候：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t Task1Handle;</span><br><span class="line">TaskHandle_t Task2Handle;</span><br><span class="line">TaskHandle_t Task3Handle;</span><br><span class="line">SemaphoreHandle_t semaphore_Handle ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> ch, FILE *f )</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> * param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1 = <span class="number">1</span>;</span><br><span class="line">flag2 = <span class="number">0</span>;</span><br><span class="line">flag3 = <span class="number">0</span>;</span><br><span class="line">xSemaphoreTake(semaphore_Handle, portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task1&quot;</span>);</span><br><span class="line">xSemaphoreGive(semaphore_Handle);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task2</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//vTaskDelay(6);</span></span><br><span class="line">xSemaphoreTake(semaphore_Handle, portMAX_DELAY);</span><br><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line">flag2 = <span class="number">1</span>;</span><br><span class="line">flag3 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task2&quot;</span>);</span><br><span class="line">xSemaphoreGive(semaphore_Handle);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task3</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//vTaskDelay(5);</span></span><br><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line">flag2 = <span class="number">0</span>;</span><br><span class="line">flag3 = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task3&quot;</span>);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">prvSetupHardware();</span><br><span class="line"></span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task1Handle);</span><br><span class="line">xTaskCreate(Task2,<span class="string">&quot;task2&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">3</span>,&amp;Task2Handle);</span><br><span class="line">xTaskCreate(Task3,<span class="string">&quot;task3&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">2</span>,&amp;Task3Handle);</span><br><span class="line">semaphore_Handle = xSemaphoreCreateBinary(); <span class="comment">// 使用信号量</span></span><br><span class="line">xSemaphoreGive(semaphore_Handle);</span><br><span class="line"><span class="comment">/* Start the scheduler. */</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310050037189.png" alt="不使用互斥量的时候"></p><p><strong>使用互斥量的时候：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t Task1Handle;</span><br><span class="line">TaskHandle_t Task2Handle;</span><br><span class="line">TaskHandle_t Task3Handle;</span><br><span class="line">SemaphoreHandle_t semaphore_Handle ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> ch, FILE *f )</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> * param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1 = <span class="number">1</span>;</span><br><span class="line">flag2 = <span class="number">0</span>;</span><br><span class="line">flag3 = <span class="number">0</span>;</span><br><span class="line">xSemaphoreTake(semaphore_Handle, portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task1&quot;</span>);</span><br><span class="line">xSemaphoreGive(semaphore_Handle);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task2</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//vTaskDelay(6);</span></span><br><span class="line">xSemaphoreTake(semaphore_Handle, portMAX_DELAY);</span><br><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line">flag2 = <span class="number">1</span>;</span><br><span class="line">flag3 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task2&quot;</span>);</span><br><span class="line">xSemaphoreGive(semaphore_Handle);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task3</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//vTaskDelay(5);</span></span><br><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line">flag2 = <span class="number">0</span>;</span><br><span class="line">flag3 = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task3&quot;</span>);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">prvSetupHardware();</span><br><span class="line"></span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task1Handle);</span><br><span class="line">xTaskCreate(Task2,<span class="string">&quot;task2&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">3</span>,&amp;Task2Handle);</span><br><span class="line">xTaskCreate(Task3,<span class="string">&quot;task3&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">2</span>,&amp;Task3Handle);</span><br><span class="line">semaphore_Handle = xSemaphoreCreateMutex();</span><br><span class="line">xSemaphoreGive(semaphore_Handle);</span><br><span class="line"><span class="comment">/* Start the scheduler. */</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310050031233.png" alt="实现优先级继承"></p><p>根据上面的现象可以看到，使用互斥量的时候可以实现优先级的继承使得任务二也能够得到执行。</p><h4 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h4><p>设想以下的画面，如果函数A获得了互斥量M1，在A的函数里面又调用了另外一个函数B，但是函数B里面也需要使用M1，此时A要等待B运行完才能运行，但是M1又在A手中，B需要M1才能执行。所以就造成了递归锁。</p><p>解决上述递归死锁的方法：</p><ol><li>避免在函数里面调用其他的会进入阻塞状态的函数。</li><li>使用递归锁，解决锁只用获取一次，即使调用的函数需要使用这个互斥量也能够获得锁。</li></ol><h5 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h5><p>创建递归锁函数：<code>SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void );</code></p><p>返回值是SemaphoreHandle_t </p><h5 id="获得递归锁"><a href="#获得递归锁" class="headerlink" title="获得递归锁"></a>获得递归锁</h5><p>获得递归锁的函数：<code>BaseType_t xSemaphoreTakeRecursive(SemaphoreHandle_t xSemaphore,TickType_t xTicksToWait); </code></p><h5 id="释放递归锁"><a href="#释放递归锁" class="headerlink" title="释放递归锁"></a>释放递归锁</h5><p>释放递归锁的函数：<code>BaseType_t xSemaphoreGiveRecursive( SemaphoreHandle_t xSemaphore );  </code></p><h5 id="递归锁案例"><a href="#递归锁案例" class="headerlink" title="递归锁案例"></a>递归锁案例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t Task1Handle;</span><br><span class="line">SemaphoreHandle_t xSemaphore;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> ch, FILE *f )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sub_Task1</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">xSemaphoreTakeRecursive(xSemaphore, portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is sub_task1\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> * param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">xSemaphoreTakeRecursive(xSemaphore, portMAX_DELAY);</span><br><span class="line">Sub_Task1(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task1\n&quot;</span>);</span><br><span class="line">xSemaphoreGiveRecursive(xSemaphore);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">prvSetupHardware();</span><br><span class="line"></span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task1Handle);</span><br><span class="line"></span><br><span class="line">xSemaphore = xSemaphoreCreateRecursiveMutex();</span><br><span class="line"><span class="comment">/* Start the scheduler. */</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310050103570.png" alt="运行结果"></p><p><em><strong>如果将上述的递归锁换成互斥量，那么将出现卡死现象</strong></em></p><h2 id="事件组"><a href="#事件组" class="headerlink" title="事件组"></a>事件组</h2><p>事件组可以在等到个别任务全部完成或等到某几个指定的任务完成之后才执行另外一个任务。例如吃饭任务需要等待买菜，买厨具，做饭，摆桌等全部的任务执行完成之后才能够执行吃饭的任务。</p><p>事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。  如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件，如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件。<br>configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑，如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位，如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310021436909.png"></p><h3 id="创建-删除事件组"><a href="#创建-删除事件组" class="headerlink" title="创建&#x2F;删除事件组"></a>创建&#x2F;删除事件组</h3><p>创建事件组使用的函数是<code>EventGroupHandle_t xEventGroupCreate( void );  </code>返回值是事件组句柄。如果创建失败则返回NULL。</p><p>删除事件组使用的函数是<code>void vEventGroupDelete( EventGroupHandle_t xEventGroup );</code>传入的参数是欲删除的事件组句柄。</p><h3 id="设置事件组"><a href="#设置事件组" class="headerlink" title="设置事件组"></a>设置事件组</h3><p>在某个任务完成之后可以设置某个事件的标志位例如A任务完成之后需要置bit0，bit9位为1。如果后面的任务需要判断A函数是否执行完成，就可以判断事件组中的第0和9位是否置1，如果置1那么表示A事件执行完成。</p><p>设置事件组的函数<code>EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,const EventBits_t uxBitsToSet )</code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xEventGroup</td><td>需要放置的事件句柄</td></tr><tr><td>uxBitsToSet</td><td>需要设置的位，例如传入0X09，表示置bit0，bit3位为1</td></tr></tbody></table><h3 id="等待事件组"><a href="#等待事件组" class="headerlink" title="等待事件组"></a>等待事件组</h3><p>跟前面的队列，互斥量、信号量类似，有人放就有人拿。有人放置事件组，那么就应该有相应的任务D等待事件组，该任务D等到事件组满足条件之后，D才能够执行。</p><p>等待事件组的函数是<code>EventBits_t xEventGroupWaitBits( const EventGroupHandle_t xEventGroup,const EventBits_t uxBitsToWaitFor,const BaseType_t xClearOnExit,const BaseType_t xWaitForAllBits,TickType_t xTicksToWait);</code>等待事件组可以是等待某一个位，也可以是等待多个位、也可以清除某些位。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xEventGroup</td><td>要等待的事件组句柄。</td></tr><tr><td>uxBitsToWaitFor</td><td>要等待的位，可以是十六进制如0x15，或则是某两个位的或值。</td></tr><tr><td>xClearOnExit</td><td>事件组满足条件之后，执行完等待指令是否要清除uxBitsToWaitFor中的位，pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除。</td></tr><tr><td>xWaitForAllBits</td><td>是否等待uxBitsToWaitFor所有的位，pdTRUE：等待所有的位 pdFALSE：等待uxBitsToWaitFor某一位。</td></tr><tr><td>xTicksToWait</td><td>等待时间。</td></tr></tbody></table><p><code>xClearOnExit</code>参数如果设置位pdFalse，那么在执行完函数等待事件函数的时候相应的位不会被清除，后续如果想清除可以使用<code>EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,const EventBits_t uxBitsToClear );</code>函数清除，但是在等待事件和清除函数之间可能被其他的任务打断然后写入新的位，后面在执行清除操作的时候就会发生误差&#x2F;错误。所以想要清除位在等待事件函数中清除可以减少原子性。</p><h3 id="等待事件组案例"><a href="#等待事件组案例" class="headerlink" title="等待事件组案例"></a>等待事件组案例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t Task1Handle;</span><br><span class="line">TaskHandle_t Task2Handle;</span><br><span class="line">TaskHandle_t Task3Handle;</span><br><span class="line">SemaphoreHandle_t xSemaphore;</span><br><span class="line">EventGroupHandle_t EventHandle;</span><br><span class="line"><span class="type">uint16_t</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> ch, FILE *f )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> * param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1 = <span class="number">1</span>;</span><br><span class="line">flag2 = <span class="number">0</span>;</span><br><span class="line">flag3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">xEventGroupSetBits(EventHandle,<span class="number">0x06</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task1 final\n&quot;</span>);</span><br><span class="line">vTaskDelay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task2</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line">flag2 = <span class="number">1</span>;</span><br><span class="line">flag3 = <span class="number">0</span>;</span><br><span class="line">xEventGroupSetBits(EventHandle,<span class="number">0x09</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task2 final\n&quot;</span>);</span><br><span class="line">vTaskDelay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task3</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line">flag2 = <span class="number">0</span>;</span><br><span class="line">flag3 = <span class="number">1</span>;</span><br><span class="line">xEventGroupWaitBits(EventHandle,<span class="number">0x0F</span>,pdTRUE,pdTRUE,portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;finally all\n&quot;</span>);</span><br><span class="line">vTaskDelay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">prvSetupHardware();</span><br><span class="line"></span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task1Handle);</span><br><span class="line">xTaskCreate(Task2,<span class="string">&quot;task2&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task2Handle);</span><br><span class="line">xTaskCreate(Task3,<span class="string">&quot;task3&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task3Handle);</span><br><span class="line">EventHandle = xEventGroupCreate();</span><br><span class="line">xSemaphore = xSemaphoreCreateRecursiveMutex();</span><br><span class="line"><span class="comment">/* Start the scheduler. */</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310050137417.png" alt="运行结果"></p><h3 id="同步点"><a href="#同步点" class="headerlink" title="同步点"></a>同步点</h3><p>同步点主要是服务于有一个事件需要多个任务同步完成，大家都完成之后才能够执行同一件事。</p><p>例如一共有三个人：</p><ul><li>A：准备食材</li><li>B：去买酒</li><li>C：做饭</li></ul><p>A、B、C只有等到上述所有的事都做完之后才能吃饭，所以吃饭时三个任务的同步点。</p><h4 id="同步点使用"><a href="#同步点使用" class="headerlink" title="同步点使用"></a>同步点使用</h4><p>创建同步点函数<code>EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,const EventBits_t uxBitsToSet,const EventBits_t uxBitsToWaitFor,TickType_t xTicksToWait );  </code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xEventGroup</td><td>同步的事件组</td></tr><tr><td>uxBitsToSet</td><td>想要设置的事件组的位</td></tr><tr><td>uxBitsToWaitFor</td><td>想要等待的事件组的位</td></tr><tr><td>xTicksToWait</td><td>可以等待的时间</td></tr></tbody></table><h4 id="同步点案例"><a href="#同步点案例" class="headerlink" title="同步点案例"></a>同步点案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">EventGroupHandle_t EventHandle;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Retargets the C library printf function to the USART.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> ch, FILE *f )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Configures the timers and interrupts for the fast interrupt test as</span></span><br><span class="line"><span class="comment"> * described at the top of this file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> * param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">xEventGroupSync(EventHandle, <span class="number">0x01</span>, <span class="number">0x07</span>, portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;All task has completed ,task1 running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task2</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">xEventGroupSync(EventHandle, <span class="number">0x02</span>, <span class="number">0x07</span>, portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;All task has completed ,task2 running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task3</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">xEventGroupSync(EventHandle, <span class="number">0x04</span>, <span class="number">0x07</span>, portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;All task has completed ,task3 running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">prvSetupHardware();</span><br><span class="line"></span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task1Handle);</span><br><span class="line">xTaskCreate(Task2,<span class="string">&quot;task2&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task2Handle);</span><br><span class="line">xTaskCreate(Task3,<span class="string">&quot;task3&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task3Handle);</span><br><span class="line">EventHandle = xEventGroupCreate();</span><br><span class="line"><span class="comment">/* Start the scheduler. */</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310052123700.png" alt="运行结果"></p><h2 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h2><p>任务通知与队列、互斥量、事件组等等不同，任务通知适用于一对一的任务通信，其中一个任务通知另一个任务以触发特定操作。通知通常用于低延迟的通信和同步需求，例如在生产者-消费者问题中使用。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310032135089.png" alt="使用队列、事件组"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310032135976.png" alt="使用任务通知"></p><p>任务通知的优势：</p><ol><li>效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都<br> 有大的优势。</li><li>更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。</li></ol><p>任务通知的限制：</p><ol><li>不能发送数据给ISR：<br> ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。</li><li>数据只能给该任务独享<br> 使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。</li><li>无法缓冲数据<br> 使用队列时，假设队列深度为N，那么它可以保持N个数据。使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。</li><li>无法广播给多个任务<br> 使用事件组可以同时给多个任务发送事件。使用任务通知，只能发个一个任务。</li><li>如果发送受阻，发送方无法进入阻塞状态等待<br> 假设队列已经满了，使用 xQueueSendToBack() 给队列发送数据时，任务可以进入阻塞状态等待<br> 发送完成。使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。</li></ol><h3 id="放入-取出数值"><a href="#放入-取出数值" class="headerlink" title="放入\取出数值"></a>放入\取出数值</h3><p>放入任务通知资源以及的函数一共有两种，一种是简约版本的函数，还有一种高级版本的函数。</p><p>简约版放入函数：<code>BaseType_t xTaskNotifyGive( TaskHandle_t );</code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xTaskToNotify</td><td>需要通知的任务句柄</td></tr></tbody></table><p>简约版取出函数：<code>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait);</code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xClearCountOnExit</td><td>在函数执行完成退出的时候是否清零</td></tr><tr><td>xTicksToWait</td><td>等待任务通知的时间</td></tr></tbody></table><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS快速入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS快速入门（一）</title>
      <link href="/2023/09/10/FreeRTOS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/09/10/FreeRTOS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要引入FreeRTOS"><a href="#为什么要引入FreeRTOS" class="headerlink" title="为什么要引入FreeRTOS"></a>为什么要引入FreeRTOS</h2><p>设想这样的场景，如果一个人需要打扫卫生，有需要写作业。这两件事的优先级是同样的。在裸机开发中面对这样的场景，如果是按照线性的方式进行程序编写如先写作业在打扫卫生或者是先打扫卫生，可能都会因为前面的任务执行的时间很长而耽误了另外一个任务的执行。（<em><strong>注：在裸机中减少任务运行时间的最好办法是使用状态机</strong></em>）。</p><p>那有没有能够“同时”执行这两种任务的方法呢？我们可以规定一个时间片，假设这个时间片是一秒，那么每隔一秒钟就切换一次任务，刚开始执行写作业的时候就开始计时，一秒钟一到就切换成打扫卫生。这样就能两个任务都将兼顾了。这就是FREERTOS的运行机制。在一些需要实时性比较强的系统中都会引入RTOS操作系统。</p><h2 id="FREERTOS结构分析及环境配置"><a href="#FREERTOS结构分析及环境配置" class="headerlink" title="FREERTOS结构分析及环境配置"></a>FREERTOS结构分析及环境配置</h2><p>FreeRTOS的下载地址：<a href="https://www.freertos.org/zh-cn-cmn-s/a00104.html">https://www.freertos.org/zh-cn-cmn-s/a00104.html</a></p><p>下载的时候<strong>不要</strong>选择LTS版本的，<strong>应该</strong>选择带有示例源码的版本。如下：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309101636002.png"></p><p>下载完解压后的目录如下：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309102225437.png"></p><p>目录中只有FreeRTOS需要用到，其他的文件可以删除。</p><p>进去FreeRTOS后里面的文件包含</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309102227921.png"></p><ul><li>Demo文件主要是示例代码</li><li>source文件时FreeRTOS的核心文件</li><li>其他的文件可以删除</li></ul><p>在Demo文件夹中包含了很多的示例程序，找到使用的IDE以及使用的芯片示例即可，其余的可以删除（根据编译报错，有时候需要留下Demo文件中的common文件夹。他是独立于Demo文件的独立文件）。</p><p>在source文件夹中，主要有一个protable文件夹，里面包含了移植文件时需要实现的参数函数。里面有各个IDE编译器的架构以及内存管理（MemMang）。留下需要的架构以及内存管理，剩下的可以删除。</p><p>MemMang文件夹中，包含heap_1\2\3\4\5，表示了5种不同的内存空间管理方法。</p><table><thead><tr><th>文件</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>heap_1</td><td>分配简单，时间确定</td><td>只分配、不回收</td></tr><tr><td>heap_2</td><td>动态分配、最佳匹配</td><td>碎片、时间不定</td></tr><tr><td>heap_3</td><td>调用标准库函数</td><td>速度慢、时间不定</td></tr><tr><td>heap_4</td><td>相邻空闲内存可合并</td><td>可解决碎片问题、时间不定</td></tr><tr><td>heap_5</td><td>在heap_4基础上支持分隔的内存块</td><td>可解决碎片问题、时间不定</td></tr></tbody></table><p>需要使用哪一种内存管理方式，只需要将相应的堆加载到程序中即可。</p><p>以下将使用keil-STM32F10x系列文件结构，将示例程序中示例代码进行删除和修改之后得到的结构如图所示：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309102242984.png"></p><p>使用示例程序修改好模板之后可以通过多次编译查找错误位置的方式将没用的程序删除。</p><h2 id="FreeRTOS基础说明"><a href="#FreeRTOS基础说明" class="headerlink" title="FreeRTOS基础说明"></a>FreeRTOS基础说明</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在FreeRTOS中定义了两个常见的数据类型分别是<code>TickType_t</code>以及<code>Base_type_t</code></p><blockquote><p><code>TickTtpe_t</code>可以是16位也可以是32位的，这取决于在FreeRTOS.h中是否定义<code>configUSE_16_BIT_TICKS  </code>如果定义了这个变量那么<code>TickTtpe_t</code>就是uint16_t类型，否则就是uint32_t类型</p><p><code>BaseType_t</code>是什么样的数据类型主要取决于MCU是什么样的架构，如果在32位架构中那么就是uint32_t，在16位架构中就是uint16_t，在8位架构中就是uint8_t。</p></blockquote><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><h4 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h4><p>FreeRTOS的变量名的是有规律的<code>变量名 = 前缀 + 含义</code></p><p>变量前缀：</p><table><thead><tr><th>前缀</th><th>含义</th></tr></thead><tbody><tr><td>x</td><td>Base_type_t 类型：结构体、任务句柄等等</td></tr><tr><td>c</td><td>char</td></tr><tr><td>s</td><td>int16_t</td></tr><tr><td>l</td><td>int32_t</td></tr><tr><td>u</td><td>unsigned</td></tr><tr><td>p</td><td>指针</td></tr><tr><td>uc</td><td>uint8_t</td></tr><tr><td>pc</td><td>char指针</td></tr></tbody></table><p>例如变量名：<code>xTaskToSuspend</code> 任务暂停变量，根据前缀x可以判断这个变量时Bse_type_t类型后面为变量的含义任务暂停</p><h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><p>函数名的命名规则主要是遵守：<code>函数名 = 返回类型+函数所在文件名+含义</code></p><p>例如创建任务的函数：xTaskCreate表示该函数的返回值为BaseType_t这个函数在Task.c文件中，作用是创建函数。</p><p><code>pvTimerGetTimerID</code>表示返回类型是void指针类型，在Timer文件中，作用是获取时间的ID</p><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><p>宏的名字可以在前面加上前缀表示这个宏在哪个文件中</p><table><thead><tr><th>宏前缀</th><th>文件</th></tr></thead><tbody><tr><td>port</td><td>portable.h</td></tr><tr><td>task</td><td>task.h</td></tr><tr><td>pd</td><td>projdefs.h</td></tr><tr><td>config</td><td>FreerRTOSConfig.h</td></tr><tr><td>err</td><td>projdefs.h</td></tr></tbody></table><p>例如：<code>portMAX_DELAY</code>表示这个宏在protable.h文件中</p><p><code>pdTRUE</code>表示这个宏在projdefs.h文件中。</p><p>通用的宏定义;</p><table><thead><tr><th>宏</th><th>含义</th></tr></thead><tbody><tr><td>pdTRUE</td><td>1</td></tr><tr><td>pdFALSE</td><td>0</td></tr><tr><td>pdPASS</td><td>1</td></tr><tr><td>pdFAIL</td><td>0</td></tr></tbody></table><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>在FreeRTOS中，任务就是函数，在执行任务时就是去执行创建任务时传入的函数指针。</p><p>在FreeRTOS中创建任务使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xTaskCreate(TaskFunction_t pxTaskCode,<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth,<span class="type">void</span> * <span class="type">const</span> pvParameters, UBaseType_t uxPriority, TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span><br></pre></td></tr></table></figure><table><thead><tr><th>变量</th><th>作用</th></tr></thead><tbody><tr><td>pxTaskCode</td><td>函数指针</td></tr><tr><td>pcName</td><td>任务名</td></tr><tr><td>usStackDepth</td><td>栈深度</td></tr><tr><td>pvParameters</td><td>传入函数的参数</td></tr><tr><td>uxPriority</td><td>任务的优先级</td></tr><tr><td>pxCreatedTask</td><td>任务句柄</td></tr></tbody></table><p>返回值：如果创建任务成功放回pdPass，任务创建失败返回errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY（-1）</p><p>创建失败的原因大部分是因为内存不足导致。</p><h4 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h4><p>优先级越高的任务优先执行，在FreeRTOS优先级取值范围为：0~(configMAX_PRIORITIES – 1)  ，值越高则任务优先级越高。</p><p>对于优先级相同的任务轮流执行。</p><h4 id="栈分配"><a href="#栈分配" class="headerlink" title="栈分配"></a>栈分配</h4><p>分配内存的时，在堆区会先创建一个头部，这个头部是一个至少包含了数据长度信息的结构体，并返回这个空间的首地址，在释放空间的时候首地址向前推得到数据的长度，从而确定需要释放的空间大小。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309241446349.png"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309241451834.png"></p><h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><p>删除任务使用的函数是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vTaskDelete(TaskHandle_t xTaskToDelete)</span><br></pre></td></tr></table></figure><p>删除任务的时候需要传入任务的句柄，任何任务都能够删除其他的任务，如果删除的任务传入的是NULL则表示任务自杀。</p><h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p>任务状态除了运行态以外，也有非运行态，但是非运行态也包含阻塞状态、暂停态、就绪态三种。</p><p>这三种非运行状态在不同场景下执行。</p><p>进入暂停状态可以是其他任务指定它为暂停状态也可以是自身进入暂停状态。但是如果要唤醒暂停状态的任务则需要别的任务进行唤醒或者是中断程序唤醒。</p><p>就绪状态是等待下一次运行的任务，他们不需要用函数调用和唤醒执行。等待时间片到达之后执行即可。</p><p>阻塞状态是被动进入状态的，在等待事件的时候不会消耗CPU，等到事件到来之后才被唤醒。这个事件可以是延迟函数、也可以是信号量，队列等等。</p><p>进入暂停状态使用VTasksuspend，但是如果要唤醒进入暂停的任务则需要其他任务执行vTaskResume来将任务唤醒。</p><p>三种状态的状态转换图如下：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309171831581.png"></p><h3 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h3><p>在FreeRTOS中有两个常用的延迟函数：</p><p><code>vTaskDelay</code>等待指定时间之后任务从阻塞状态编程就绪状态</p><p><code>vTaskDelayUntil</code>等待绝对时长之后变成就绪状态</p><h3 id="空闲空间"><a href="#空闲空间" class="headerlink" title="空闲空间"></a>空闲空间</h3><p>空闲任务主要用于清理被删除的任务，释放空间。由于空闲任务的优先级为0，所以空闲任务不能进入阻塞和暂停状态，并且空闲任务执行的时间不能过长。</p><p>空闲任务在开启任务的时候就会自动调用空闲任务，如果我们需要在空闲任务中添加任务，不需要自己写空闲任务，在空闲任务中提供了一个钩子函数<code>vApplicationIdleHook  </code>。在使用这些函数的时候需要注意宏定义，有一些函数需要在定义宏之后才能使用，否则不能执行报错。调用钩子函数的时候不能使用while(1)以防空闲任务有其他的任务要做。</p><p><strong>由于空闲任务的优先级是0，空闲任务的优先级最低但是空闲任务确实很重要的，所以要保证空闲任务有执行的机会，如果其他二任务优先级都比空闲任务高并且这些任务都不进入阻塞或暂停状态，那么空闲任务将没有机会得到执行，那么删除任务之后被删除的任务的空间将得不到释放，在后续的执行中有可能空间不足导致系统奔溃。</strong></p><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>调度策略的配置一共有3中配置，一般是在FreeRTOSConfig.h文件中</p><blockquote><ol><li>可否抢占优先级（configUSE_PREEMPTION）<ol><li>可以抢占，则高优先级先执行</li><li>不可以，则高优先级不能抢占资源，只能能等待前面的任务执行完成之后才可以</li></ol></li><li>可以抢占优先级的前提下，同优先级是否支持时间片轮转（configUSE_TIME_SLICING）：<ol><li>支持时间片轮流：表示相同优先级的任务轮流执行，每个任务执行一个时间片</li><li>不支持时间片轮转：表示同个优先级的任务不能轮流执行，前面一个任务一直执行直到该任务主动放弃或高优先级抢占为止。</li></ol></li><li>在可以抢占优先级+支持时间片轮转的情况下空闲任务是否让步于用户任务（configIDLE_SHOULD_YIELD）：<ol><li>空闲任务主动让步于用户任务：表示在相同优先级的情况下空闲任务只有等到其他任务执行完成或者主动放弃执行为止空闲任务才能够执行</li><li>不让步于用户任务：则表示空闲任务会争夺相同优先级任务的执行权。</li></ol></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS快速入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用HEXO以及Github搭建博客</title>
      <link href="/2023/08/27/%E4%BD%BF%E7%94%A8HEXO%E4%BB%A5%E5%8F%8AGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/08/27/%E4%BD%BF%E7%94%A8HEXO%E4%BB%A5%E5%8F%8AGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="工欲善其事"><a href="#工欲善其事" class="headerlink" title="工欲善其事"></a>工欲善其事</h1><h2 id="Git下载及配置"><a href="#Git下载及配置" class="headerlink" title="Git下载及配置"></a>Git下载及配置</h2><p>电脑中需要安装git，没有git中可以在<a href="https://git-scm.com/downloads">官网</a>中下载。安装的时候一路next即可，也可以选择自己要安装的目录。</p><p>安装好git后，打开Git Bash(如图)</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271539904.png" alt="Git Bash"></p><p>然后使用以下git命令绑定账号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;github中的用户名&quot;</span><br><span class="line">git config --global user.emil &quot;github绑定的邮箱&quot;</span><br></pre></td></tr></table></figure><h2 id="Nose-JS下载"><a href="#Nose-JS下载" class="headerlink" title="Nose.JS下载"></a>Nose.JS下载</h2><p>hexo是基于Nose.js框架下驱动的，所以使用hexo创建网站的时候需要下载（Nose.js)[<a href="https://nodejs.org/en/download]%E6%A1%86%E6%9E%B6%E3%80%82">https://nodejs.org/en/download]框架。</a></p><p>以上步骤完成之后，可以使用<em>git -version</em>或者<em>npm -v</em>进行测试。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271553490.png" alt="测试下载"></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>在git中输入<em><strong>npm install -g hexo-cli</strong></em>下载hexo</p><h2 id="在github中创建静态网站的仓库"><a href="#在github中创建静态网站的仓库" class="headerlink" title="在github中创建静态网站的仓库"></a>在github中创建静态网站的仓库</h2><p>每一个账号都只能有一个repo个人主页，并且这个网站要放在maser分支上。在github中创建一个仓库，这个仓库的名字有严格的要求，格式为：&#x3D;&#x3D;用户名&#x2F;用户名.gothub.io&#x3D;&#x3D;，例如：xiaobini&#x2F;xiaobini.github.io，这里的用户名是Github的用户名，必须是Github用户名。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271607646.png" alt="仓库创建"></p><h1 id="利剑出鞘"><a href="#利剑出鞘" class="headerlink" title="利剑出鞘"></a>利剑出鞘</h1><h2 id="使用HEXO生成原始网站"><a href="#使用HEXO生成原始网站" class="headerlink" title="使用HEXO生成原始网站"></a>使用HEXO生成原始网站</h2><p>在任意位置右键打开Git Bash或者是使用cd指令进入，总之命令行要指向该窗口，我将博客的文件存放到D:\myblog中。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271625942.png"></p><p>然后在git中分别执行下面指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init blog  #这里的blog可以是你自己喜欢的名字</span><br><span class="line">cd blog</span><br><span class="line">nmp install</span><br></pre></td></tr></table></figure><p>如果上面指令都没有出错的话，可以输入 hexo s启动服务，然后在<a href="http://localhost:4000/">http://localhost:4000</a> 中可以看到该网站的最初形态。</p><h2 id="加载主题"><a href="#加载主题" class="headerlink" title="加载主题"></a>加载主题</h2><p>关于hexo中的各个主题可以在<a href="https://hexo.io/themes/index.html">hexo主题</a>中获得，下面就以<a href="https://github.com/blinkfox/hexo-theme-matery">matery</a>为例。</p><p>绝大多数主题作者都会告诉安装以及配置方式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/blinkfox/hexo-theme-matery.git # 使用该指令下载主题</span><br></pre></td></tr></table></figure><p>打开博客根目录（D:\Myblog\blog），找到_config.yml，打开后拉到最后找到theme。将landscpe替换成主题名字。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271759461.png" alt="主题配置1"></p><p>下载后将主题放置到hexo生成文件中的themes文件夹（D:\Myblog\blog\themes）中。这个时候在git中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 更新生成</span><br><span class="line">hexo s # 开启服务</span><br></pre></td></tr></table></figure><p>这个时候再打开<a href="http://localhost:4000/">http://localhost:4000</a> 就能看到主题。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>打开主题文件夹（D:\Myblog\blog\themes\hexo-theme-matery）找到_config.yml进行主题配置。</p><p>根据作者的描述，如果需要在网页中加上分类或者是标签的话需要在git中使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;tag&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271654345.png" alt="配置主题1"></p><p>输入后在博客目录的sorce文件夹下会分别生成tag、categories文件夹。这两个文件夹里面包含了index.md，打开后将头部修改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tag文件夹中的index.md加入</span></span><br><span class="line">title: tags</span><br><span class="line">date: 2018-09-30 18:23:38</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">categories文件夹中的index.md加入</span></span><br><span class="line">title: categories</span><br><span class="line">date: 2018-09-30 17:25:30</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271658498.png" alt="tag配置"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271700473.png" alt="categories配置"></p><p>以后在写文章的时候在文章的头部分别加入tag、categories就可以在网页中点击该栏目的时候看到这个文章。</p><p>关于其他的配置这里栏目的配置参照github中作者的配置。</p><p>自己需要的栏目配置好后，打开主题里面的__config.yml文件，进行配置。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271703854.png" alt="栏目配置"></p><p>关于其他的配置如音乐播放、背景图片、文字等等也都是在这个文档中进行配置，根据作者在这个文档中的注释进行配置。不在赘述。</p><p>配置好主题后重新输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 更新生成</span><br><span class="line">hexo s # 开启服务</span><br></pre></td></tr></table></figure><p>即可在<a href="http://localhost:4000/">http://localhost:4000</a> 查看网页配置的情况。</p><h2 id="博客部署到Github上"><a href="#博客部署到Github上" class="headerlink" title="博客部署到Github上"></a>博客部署到Github上</h2><h3 id="SSH-Key配置"><a href="#SSH-Key配置" class="headerlink" title="SSH Key配置"></a>SSH Key配置</h3><p>在git中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;</span><br><span class="line">ssh-keygen -t rsa -C &#x27;上面的邮箱&#x27;</span><br></pre></td></tr></table></figure><p>根据提示三次回车后生成ssh key。</p><p>之后再git中使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>查看ssh密钥，复制这个密钥打开github，在Settings中找到 SSH and GPG keys。点击Nnew SSH Key。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271719546.png" alt="github ssh配置"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271721704.png" alt="SSH 配置"></p><h3 id="根目录配置"><a href="#根目录配置" class="headerlink" title="根目录配置"></a>根目录配置</h3><p>生成之后，打开博客根目录（D:\Myblog\blog）下的__config.yml，进行博客的配置。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271641408.png" alt="config配置1"></p><p>拉到最下面找到deploy，配置如下。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271728990.png" alt="deploy配置"></p><blockquote><p>type: git —-必须是git</p><p>repo：<a href="http://github.com/%E7%94%A8%E6%88%B7%E5%90%8D/%E7%94%A8%E6%88%B7%E5%90%8D.github.io.git">http://github.com/用户名/用户名.github.io.git</a>     # 用户名&#x2F;用户名.github.io  这个为刚刚创建的仓库。&#x3D;&#x3D;必须是这个格式&#x3D;&#x3D;   branch：master   </p></blockquote><p>配置好上面的步骤之后，需要在根目录下下载部署插件，在git中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h3><p>经过上面的步骤如果到此为止还没有出错的话那么恭喜你。这是最后一部。</p><p>在git中使用如下命令上传到github</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g #更新文件</span><br><span class="line">hexo d # 上传到服务器</span><br></pre></td></tr></table></figure><p>上面的指令没有问题的话可以在github仓库中看到本地的文件</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271735224.png" alt="github文件"></p><h1 id="开始搬砖"><a href="#开始搬砖" class="headerlink" title="开始搬砖"></a>开始搬砖</h1><h2 id="创建新的文章"><a href="#创建新的文章" class="headerlink" title="创建新的文章"></a>创建新的文章</h2><p>在git中输入<em><strong>hexo new “文章名”</strong></em>即可在source文件夹下的_posts文件夹看到生成的文章，这个文章只能支持markdown语法。</p><p>刚开始创建的文章头部为</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271739237.png" alt="文章头部"></p><p>我们可以根据之前的配置在文章头部加上如author，categories、tag标签。需要注意的是，标签与后面内容之间需要使用空格隔开，否则使用<strong>hexo g</strong>会报错。</p><p>文章头部还可以配置哪些功能可以参考作者的说明：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271742924.png" alt="文章配置说明"></p><p>写完文章后想要更新到github上还是按照上面的步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h1 id="关于上传时需要登陆的情况"><a href="#关于上传时需要登陆的情况" class="headerlink" title="关于上传时需要登陆的情况"></a>关于上传时需要登陆的情况</h1><p>有的时候在上传的时候会遇到要求登陆的情况，但是没办法使用用户名+密码的形式登录。这里需要使用Github中的token。</p><h2 id="github-token创建"><a href="#github-token创建" class="headerlink" title="github token创建"></a>github token创建</h2><p>在settings中拉到最下面找到Develop Settings，找到token</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271747757.png" alt="token创建"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271748418.png" alt="token创建2"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271750761.png" alt="token配置3"></p><p>拉到最下面确认生成token即可，token要记住，这个token只显示一次，后面不在显示。</p><p>在本地网站根目录下找到_config.yml并打开，拉到最下面的deploy中加入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token: 刚刚复制的token</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271753792.png" alt="token配置4"></p><h1 id="hexo-d上传超时解决办法"><a href="#hexo-d上传超时解决办法" class="headerlink" title="hexo d上传超时解决办法"></a>hexo d上传超时解决办法</h1><p>将配置项中的repo改成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo:git@github.com:/用户名/用户名.github.io.git</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂类技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
