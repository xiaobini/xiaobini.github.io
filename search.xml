<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>充电柜项目总结</title>
      <link href="/2024/04/17/%E5%85%85%E7%94%B5%E6%9F%9C%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2024/04/17/%E5%85%85%E7%94%B5%E6%9F%9C%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>历经一个月的时间，总算是把公司交待下来的项目完成的差不多了，也跑了很久的测试优化了不少的问题。虽然把这个项目的每个功能拆开来看都不算是很难，但是整合在一起还是挺有难度的，尤其是在时间那么紧急的情况下（对于我而言的）。整个项目单片机那块的软件部分都是我一个人干所以每天都要加班加点。已经一个多月没有休息了，最晚的时候干到了凌晨两点生怕在这里没测出问题，在用户那里出现了问题。但是得到的好处就是在这个项目要中学到了不少的东西。躺过了很多的坑，不管是软件还是硬件的坑都踩过了。所以对于项目还是有不一样的心得体会的，故写下如下我称之为踩坑心得。</p><p>（这里吐槽一下，在客户来检查的那一天才把硬件贴出来给我的硬件工程师。然后信誓旦旦的说这个项目的压力都在软件这一边不要老是去催我，合着就是这么给我上压力的是吧。:rage:）</p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>这个项目主要是放在韩国的校园里面的手机、平板、电脑的充电设备，支持40个手机、平板和电脑充电。支持不少快充协议。使用的是厂商提供的快充方案。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202404171934261.png" alt="支持的快充协议"></p><p>整个设备分为控制板、充电板、触摸屏HMI以及app这几者之间的联系。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202404180036304.png" alt="联系"></p><h2 id="充电板的主要功能"><a href="#充电板的主要功能" class="headerlink" title="充电板的主要功能"></a>充电板的主要功能</h2><p>顾名思义，充电板的主要功能就是给设备充电用的，主要核心的部分就在于控制快充IC，快充IC是使用IIC通信的，主控芯片选择的是STM32F030。每个做单片机或者称之为嵌入式的人都应该必备的阅读芯片手册的本领，所以控制这个IC也是阅读IC的datasheet和寄存器手册。这里就没什么好啰嗦的了。BUT，虽然是这么说没有错，但是这里却是在我有限的项目周期里耗费我不少时间的地方，原因在于，厂家提供的芯片存在不小的问题。这里不方便透露厂商名字，这里用‘A’代替芯片的名字，我们公司购买的也是芯片A，但是厂家发的却是As，没错多了个s。就是这个s耗费了不少时间，说来也奇怪，A和As之间我用到的几个主要寄存器都是通用的，寄存器的地址也一样，询问厂家之后也说是一样的没问题，但是同样的硬件同样的软件，在这两个之间却完全不一样，A能够读取出寄存器里面的数据但是As读出来的却是乱码。刚开始怀疑是芯片坏了，但是试过了很多个As芯片之后都是乱码。同样的程序在A中完全可行。这里商家也没有给出具体答案，技术支持估计也很头疼。所以说有时候出问题了也很有可能不是自己的问题，不然陷入深深的自我怀疑中还挺痛苦。。。。</p><h2 id="控制板主要功能"><a href="#控制板主要功能" class="headerlink" title="控制板主要功能"></a>控制板主要功能</h2><p>控制板的功能比较多，但是都比较简单，感觉最难的还是在处理通信数据以及通信速度的问题上。</p><p>控制板主要是一下几个功能。</p><p>通过控制继电器以及通讯来控制充电板的充电，支持通过屏幕设定充电时间开始时间和结束时。因为这个项目主要是韩国的项目，并且主要是放在学校的。对于设备的电压承载能力没有那么强，所以不能一次性全部打开，只能一层一层的慢慢开启。所以也能够通过屏幕设置每一层的延迟打开时间。</p><p>监视门当前的打开和关闭状态，控制门锁的打开和关闭。读取NTC的值计算出当前的温度，并且与屏幕上的设定温度进行比较，如果大于设定温度则打开风扇，小于则关闭。如果温度超过70度，则断电保护。</p><p>读取烟雾报警器的状态，如果检测到烟雾报警则断电保护。在关门的时候要打开紫外光进行消毒，开门的时候务必关闭紫外灯避免伤人。</p><p>与ESP32之间的通信。这也是接这个项目之前没有接触的部分，不管是WIFI还是MQTT都是没有接触过的。当时听到这两个功能的时候都是懵的，生怕完不成任务。但是后面学习之后其实也还好，不过也只是停留在应用层面，后面也是要深入学习一下，做一些比较有意思的东西出来玩玩。ESP32的的开发使用的是Arduino,原本想用ESP-IDF的，但是时间太紧了没办法选择了最快开发的道路。</p><p>与屏幕的交互，屏幕是另外一位老兄写的。他也是第一次接触屏幕，所以写的也不是很熟，但是最后的结果还是好的。更这位老兄的合作也比较愉悦。跟屏幕交互还是相对简单的，主要是通过串口发送一些字符串指令，但是也有一些不简单的点后续会讲。</p><p>以上就是这个项目的基本功能，现在看起来这个功能确实是不多也不是难的项目，但是应客户的要求整合逻辑还是一件比较麻烦的事。在硬件还没有出来之前写的很多东西只能说能用，但是用不流畅而且在调试的过程中BUG也不少。所以空写程序问题还是很多的。不过这也没办法（也可能是我刚出社会，还没有足够的经验和技术）。</p><h1 id="数据稳定和校验的必要性"><a href="#数据稳定和校验的必要性" class="headerlink" title="数据稳定和校验的必要性"></a>数据稳定和校验的必要性</h1><p>数据稳定和校验的比较性真是我在这个项目中学到的最宝贵的经验。这个主要是在控制板和充电板之间的数据通讯，因为一共有4个充电板都连接到控制板上使用的是485通信。所以只能通过逐层扫描的方式进行充电板的控制以及获取当前充电板的信息（当前每个充电口快充、，慢充、电流和电压数据）。每次发送的数据每个充电板都能收到，在收到数据之后都会拿这个数据跟自己的ID进行比较。如果不是自己的则忽略，是自己的则获取自己当前充电口信息打包一起发送给控制板。</p><p>就是这样的操作在我拥有一个控制板和一个充电板的时候觉得是很简单的，所以我发送的ID也比较简单，我用的是00\01\02\03这样的指令直接发送给每个充电板，完全没有考虑外部干扰和电路纹波的情况，在测试单个充电板的时候完全没有问题，应为没有其他充电板的数据干扰，来的数据也只有这样一层的数据。但是在拿到三块充电板的时候人就傻了，三个充电板因为受到干扰导致数据错乱，有时候发送的数据短了，导致控制板那边接收到的数据长度不对又会等到下一个板的到来补齐后面的长度。所以就导致了控制板处理数据混乱。这是一个很致命的点，这意味着任何通过充电板来控制板的数据都是错的。以至于屏幕上显示的的数据也是错的。</p><p>这个问题那时候考虑了很久，是一个比较有经验的大哥跟我说这样很容易受到干扰，所以我在原本发送ID的基础上加上了反ID，也就是原本发送一个字节的现在发送了两个字节，第一个字节是充电板的ID另外一个字节则是~ID。这样充电板的数据可算是不会乱飞了，为了稳定性我在充电板打包发送的那些数据中加了最后一位的校验位，LCR校验，通过前面的数据计算出校验位。这样就有了双重保障。数据的运行也稳定了不少。</p><h1 id="RS485相关"><a href="#RS485相关" class="headerlink" title="RS485相关"></a>RS485相关</h1><p>关于485通信的坑主要分为两个，一个是硬件的坑一个是软件的坑</p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>虽然做这个项目的硬件工程师是我们公司的兼职（在外面有自己的小生意），但是怎么也是有20多年的工作经验了，所以我对硬件工程师无比的信任，对于我这个刚毕业不久的来说有问题也只能找自己的问题。所以在后面的测试中都没有怀疑是硬件的问题。</p><p>485中存在4个脚，两个分别是收发使能脚，还有两个分别是收发数据脚。结果硬件工程师把收发引脚弄反了，我是在查了一天的问题之后实在是没办法才去看的芯片手册（因为之前的项目也用过这个芯片，所以还记得，甚至去看了这个项目写的485通信一模一样但是就是不行，快崩溃了。。。）</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202404172333228.png" alt="image-20240417233339129"></p><p>这个芯片的R0引脚应该对应的是单片机的RX，DI引脚对应的是TX引脚。无奈只能飞线。</p><p>还有一个坑是，在控制板上的485芯片，测试了两天还是收发不了数据，一直以为是使能引脚没有写好故排查了很久。最后发现是485芯片没给我供电！！！！至此后面的问题有问题都先排查硬件。一个搞软件的大哥说这才是基本素养。:smile:</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>好了，上面的硬件的坑就当作是在抱怨吧。软件部分才是吃饭的家伙。</p><p>485是一个半双工的通讯标准，所以在通讯的时候需要切换使能电平。就是这个切换电平需要特别的注意。</p><p>在控制板和充电板板之间就是没有控制好收发使能的时间导致浪费了不少的时间在找BUG。主要是因为使用了一个滴答时间来定时逐层扫描，所以存在这样的情况，在接收到上一层的充电板的数据的时候正好时间到了所以使能状态切换。导致接收到的数据变短。解决方法就是在接收到上一层的数据的时候置零滴答计时器，在接收完数据之后在重新计时。</p><p>每次状态切换的时候都需要有一小段时间的延迟，延迟也不用太大，2ms对单片机来说完全足够。</p><p>485通信可以携带多个设备，这一点对于串口少的单片机来说相当的方便。而且485是使用差分线进行比较的，传输的数据稳定性也得到了比较好的保障。</p><h1 id="IIC通讯问题"><a href="#IIC通讯问题" class="headerlink" title="IIC通讯问题"></a>IIC通讯问题</h1><p>关于IIC通讯的坑踩的还是比较少，但是也是踩的痛彻心扉。</p><p>在写IIC通讯得时候大部分都是在成熟代码上移植（抄）过来的，对这些已经在别的设备上验证过的程序还是比较自信的，相信不会出什么错误。但是还是大意了。不管是使用逻辑分析仪还是示波器，怎么样抓波形器件都没有响应。这时候还是怀疑自己的程序出现了问题，排查了好一会。猛然想起，<strong>硬件是不是没有加上拉电阻？</strong>。然后立刻去检查了原理图，发现果然，没有加上拉电阻，器件回个锤子的应，遂告知硬件工程师整改。后面就得到了一个满满飞线的板子。</p><p>&#x3D;&#x3D;IIC通讯切记一定要加上拉！！！！！！！！！！！！&#x3D;&#x3D;</p><h1 id="中断与状态机问题"><a href="#中断与状态机问题" class="headerlink" title="中断与状态机问题"></a>中断与状态机问题</h1><p>这个项目涉及到的通讯指令比较多，尤其是与屏幕之间的通讯的时候，如果一次性把所有的数据都发送过来没有很必要，最好就是在用户操作的时候发送对用的操作即可。所以我与屏幕的通讯协议采用指令+操作数值的方式来进行操作。这个跟ESP32与STM32F103的通讯方式一样。所以使用串口中断加上状态机的方式进行数据的控制和写入。</p><p>使用这种方式就导致了一个问题这也是我跟屏幕配合的时候遇到的一个问题，如果在短时间内发送两条指令，会出现其中一条指令接收不到，或者是接收到了第二条指令但是接收不到第二条指令的值，这就导致了状态机出现问题。</p><p>排查了一下原因后发现，在中断里面处理一些指令的时间太长导致丢失了部分数据，这也是一个教训，刚开始遇到这种情况都是让写屏幕的老兄加延迟时间，但是延迟也不能加太大不然影响用户体验。</p><p>所以我优化了在中断中处理数据的方式，在中断中为了不让处理数据的时间过长，所以使用标志位的方式将数据处理丢到主函数的循环中，你说这样会影响用户体验吗？执行的单一指令的数据的响应速度肯定是不如之前，但是慢不了多少，可能5~6ms。但是这样换来的是数据的稳定接收以及状态机的稳定。</p><p>而ESP32在接收到MQTT数据并传送回STM32的时候也会出现这样的问题，并且后面还有一个时间戳返回的问题所以后面ESP32接收到的数据不进行数据裁剪划分，全部传送给STM32并且STM32在中断不处理任何数据，数据的处理都放在主函数中，这样大大增加了系统的稳定性。否则的话在反馈数据的时候时间戳偶尔会出现问题。导致后面的MQTT在反馈的时候时间戳错乱；</p><p>之前就听别人说过&#x3D;&#x3D;在中断中不要出现长时间的循环以及长时间执行的程序&#x3D;&#x3D;，那时候只知道这句话，但是只有自己真正体会，并且通过无数个加班的夜晚才能换来教训。</p><h1 id="关于工具的使用"><a href="#关于工具的使用" class="headerlink" title="关于工具的使用"></a>关于工具的使用</h1><p>这个项目给我体会最深的就是人与动物会不会使用工具的区别。说实在的，真切感觉自己在硬件方面和一些工具之间的使用的薄弱。也是需要不断去弥补的。这个项目最常用的除了基本的JLINK仿真和485转USB之外。最常用的就应该是逻辑分析仪了。以前没有接触过这个玩意。现在接触到之后是真的香~。分析各种协议就特别的好用。用起来也比较简单没有什么复杂的东西（可能是没有用到高级功能）。</p><p>这个项目除了使用逻辑分析仪之外的另外一个大家伙就是示波器了。关于示波器真是感觉很惭愧，作为功课专业的学生示波器的使用仅仅会auto键。所以这个项目分析一些具体问题的时候我分析半天的事，搞了多年软件的大哥拿着示波器点点，就定位到了问题点。不然我只会在程序上这改改那改改试试效果。后面查出来是485芯片坏了，换了一个就好了。示波器的使用是真的必会的一个技能，所以有时间一定要把示波器好好的学透点。</p><p>碰巧的，笔者写下这篇文章的时候正式AI日新月异的时候，各家的大模型飞起。可以说是带来了一波新的AI革命。既然身处这个时代就应该顺应时代的潮流，以后AI的发展肯定会更快，我都不敢想以后。。。咳咳咳。说回正题，刚刚说话的意思就是要利用好AI这个工具，现在很多人都比较忽视大模型这个工具，但是他可以是你在学习路上的老师，一本海纳百川的百科全书，一位面试官，也可以是你的奴才。很多在网上查找起来比较繁琐的东西都可以询问一下AI。这个项目AI对我的帮助不小，他给我解释了很多的名词、帮我写了不少的程序（主要是一些简单但是比较重复性的程序），加快了项目的开发速度。这里重点提一下通义千问和Chatgpt，因为这两个的帮助让我省区了很多麻烦。在写下这段的时候Chatgpt依然是全球第一梯队，对于通义千问的表现对于我而言是够用了。</p><p>焊接技术也是一个不能缺少的技术，作为嵌入式软件\单片机工程师是需要与硬件打交道的，如果硬件中某个电子元器件之类的坏了，不需要去麻烦别人或者是硬件工程师。自己焊接好能够省下不小的等待时间。电烙铁还是必须要会的，不然吹牛逼别人问起来都不好说自己是这个行业的。虽然笔者的焊接技术也属实一般，现在还在慢慢学习的阶段。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个项目看起来比较简单，但是对于菜鸡的我还是收获颇丰的，不枉我几乎每天11点回家周日还去加班的努力。后续会根据客户的需求继续完善各项功能。这个项目中学到最大的还是规划，在动手前一定要规划好整个程序的框架，不然后面补起来真的是像手里拿着水泥，那里有逢糊哪里。整个程序看下就跟:shit:一样。遇到事情不要慌也是一个心理需要不断去打磨的事，想起那天加班到两点被客户跟老板在旁边指指点点程序要怎么改，他们不懂程序而且指导的方向又是错的，那时候拳头比石头还硬。。。后来还是自己一个人的时候才冷静分析出问题来的。</p>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次使用标准库官方模板疯狂报错解决方案</title>
      <link href="/2024/03/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%98%E6%96%B9%E6%A8%A1%E6%9D%BF%E7%96%AF%E7%8B%82%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2024/03/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%98%E6%96%B9%E6%A8%A1%E6%9D%BF%E7%96%AF%E7%8B%82%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>今天接到了一个项目，需要使用STM32F030R86,所以需要重新配置环境，由于用惯了标准库并且项目时间很紧，所以决定使用标准库。在官网下载了STM32标准库。里面除了基本的固件库之外还有一个STM32自己的模板文件。所以不需要自己配置.</p><p>原以为打开直接更改一下IC选择配置一下就好了，等到编译的时候我傻眼了。怎么编译的时候会报200多个错误、200多个警告。于是请教了度娘，得到的答案是说使用keil的时候版本选错了，要选择keil5版本的在编译就不会报错。有人成功了，说明这个方法时可行的，但是我尝试之后无果。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202403092332561.png" alt="错误信息"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202403092334330.png" alt="修改keil版本"></p><p>最后我拿了一个其他人配置好的文件进行对比，两个明明一模一样的配置为什么他能跑通但是我却不行，在一番排查过后我发现，其中一个文件“stm32f0xx.h”文件不是使用的下载下来的库文件。而是直接使用的之前安装的芯片包里面的文件，导致了这个文件的版本更其他文件对不上。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202403092337086.png" alt="打开文件所在文件夹"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202403092338711.png" alt="使用的是芯片包里面的文件"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202403092339080.png" alt="应该使用下载的库文件里面的文件"></p><p>对它进行更换之后编译成功。</p><p>&#x3D;&#x3D;ps:也有可能是直接在C\C++那个选项下没有加入stm32f0xx.h的路径，导致系统使用默认的文件。&#x3D;&#x3D;</p><p>找了半天也没有找到更换路径的办法，于是先临时删除那个芯片包文件，编译之后等到stm32f0xx.h使用的是下载的标准库的数据时在将原来的芯片包还原回去即可。</p>]]></content>
      
      
      <categories>
          
          <category> 解决问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32、文件配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业工作半年的总结</title>
      <link href="/2024/02/12/%E6%AF%95%E4%B8%9A%E5%B7%A5%E4%BD%9C%E5%8D%8A%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2024/02/12/%E6%AF%95%E4%B8%9A%E5%B7%A5%E4%BD%9C%E5%8D%8A%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><p>2023年7月1号毕业，到现在的工作也是磕磕绊绊。</p><p>第一份工作是在广州的新代科技，这份工作是校招的时候找的，应聘的是硬件工程师的岗位。那时候想的是大学四年主要都是在学习软件，对硬件的设计和理解都比较有限，并且考研的时候专业课是模电数电所以上手不会说完全没有基础，就想着先学一下硬件，之后想干嵌入式软件的时候在转。那时候的HR跟我说的是去那里主要负责的是硬件测试和维修。我想刚上手肯定不可能就让你设计的，于是就答应了。没想到这个公司就是专门干维修的（笑哭）。里面没有研发岗位，没有传统意义上的硬件工程师。所以在的那一个月让我深陷怀疑。</p><p>在新代练习了一个月的焊接技术，现在的焊接水平不能说很厉害但是一些常见的电子元器件都可以焊接。在那里认识到了将来大哥，他手把手的教我焊接，还是很感谢来哥。但是在这家公司中看不到未来，不想一辈子都在干着维修的活，所以在工作了一个月之后就辞职了。</p><p><strong>要说在第一份工作中获得的教训或者是经验的话，就是找工作的时候要看清公司的性质，不能够自以为是的去猜想。</strong></p><p>辞职后，找了一个月的工作。最后找到了现在的这家公司（暂时保密）。现在的这家公司主要是做程控电源（开关电源的一种分类）以及非标自动化产品。</p><p>现在在这家公司依然还是实习阶段，早上8小时基本都是在产线上进行焊接以及一些装配的活，然后每天晚上在开始学习代码以及公司的产品。转正的一个条件就是要完成公司指定的一个产品。但是实习了6个月，因为每天早上打杂，晚上在公司学习的时间还是比较少的。所以经常需要回家之后自学。</p><p>我的一个项目是完成82V&#x2F;10A&#x2F;100W的产品。刚开始公司之后两台这样的机器，有一台是硬件工程拿给我说是测试好的，我上电之后就炸了（这个公司方面一直判定是我的错，我也不想辩解太多）。还有一台可能是我的原因，不知道这样的产品在写程序的时候需要限制功率，不然产品会炸。所以在写入程序的时候给了比较大的占空比导致产品超出功率。就这样两台机器都需要硬件工程师维修。很可惜的是负责这个产品的硬件工程师是公司的兼职，并不是全职。所以不会花时间来维修产品。也一直跟我说不要去催促。就这样磨了两个月才修好一部给我。后面进行调试的时候，硬件本身的原因导致电流在调节的时候一直跳，后面一个更加资深的硬件工程师看后觉得纹波太大所以叫兼职的硬件工程师改走线。磨来磨去中间做了一些小的项目，也帮客户改了一些比较简单的代码。电源那边硬件一直都有问题所以就一直没弄出来。</p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>工作半年的时间确实有很大的感悟，这些感悟最多的是来自人情世故之间关系的复杂，人与人之间的各种利益关系导致的不同的人说话之间有着很大的不同。</p><h3 id="屁股决定脑袋"><a href="#屁股决定脑袋" class="headerlink" title="屁股决定脑袋"></a>屁股决定脑袋</h3><p>在新代的时候感觉每个人都很纯粹，因为大家都是打工人，没有什么股东和老板之类的存在，虽然有主管什么的但是都很年轻，所以感觉人都比较好。在现在这家公司虽然人数比不上新代的人数多（只有十几个人），但是还是很复杂的。毕竟里面既有老板也有股东（一个大老板，两个技术入股）。虽然在交流的时候大家都是笑着也从来没有什么争吵，但是在跟他们交流的时候会时不时的“画饼”，类似于在这里做几年给你送房送车之类的话。然后另外一个股东则是喜欢说，刚出来都是打螺丝的不要在意什么利益关系。虽然是这样说但是他们给的待遇真的很差，还不如打螺丝的。如果是去跟一些像我这样既不是股东又不是老板的员工说话的时候，倒是比较随和一些，因为彼此之间的利益关系没有那么大。也是这样我才慢慢的体会到<strong>“屁股决定脑袋”</strong>这句话。后来在跟别人的交往之中都会先弄清楚对方的身份，确定好与我之间的利益关系后，接下来他说的每一句话都会思考在他那个立场上说这句话的目的。这样看起来很没有人性，但是也减少了被骗的风险。</p><h3 id="在职场不要暴露自己的意图，不能心急回复"><a href="#在职场不要暴露自己的意图，不能心急回复" class="headerlink" title="在职场不要暴露自己的意图，不能心急回复"></a>在职场不要暴露自己的意图，不能心急回复</h3><p>这个也算是对我来说一个惨痛的教训了。因为是硬件那边的原因导致的项目一直没有完成，所以老板也不能给我转正。就把我叫过去说培养我的话一个月只给2000然后签3年，这3年内不能辞职之类的。当时我一直在想着一个借口回绝，因为这一份合同太不平等，就跟签卖身契一样。但是又不想伤了双方的面子，于是乎就说自己要去考研，这一说老板心里肯定更加不愿意了，虽然当时老板表面上说着往更高走肯定是好的，也在鼓励这种事，所以我也没怎么当回事，以为这件事应该算是糊弄过去了。再后来跟那个兼职硬件工程师的同事吃饭的时候他跟我说的。</p><p>“老板跟我说你想去考研，所以有点不敢培养你，怕培养完之后你走了。”</p><p>那时候我就知道自己错了，那个兼职硬件工程师的同事跟我也是老乡了，一直在鼓励我好好学习。是一个60多岁的老前辈了。他告诉我说，<strong>以后在职场上不要把自己的真实意图告诉别人，不管这个人跟你的关系怎么样，只要你们是同事就不行。同事不该是朋友，除非你离开这家公司或者你们不在同一家公司上班了，那样才能成为朋友。</strong>第一次出社会，没想到这么小的公司也是这么讲究很多职场规则。也是因为这个可能过完年之后又要开始找工作了，在这里学到不少的知识，到时候单开一篇文章总结吧。</p><h3 id="万事谨慎"><a href="#万事谨慎" class="headerlink" title="万事谨慎"></a>万事谨慎</h3><p>这几天一直在看《教父》这部小说，一直很喜欢老教父的一句话，<strong>“我用一辈子学会了谨慎。”</strong></p><p>谨慎这件事主要源于我，在调试电源的时候有时候容易有冒进的思想，有的时候我会直接给一个很高的占空比导致电源损坏之类的。我经常在想如果我能够谨慎一点，从0开始慢慢的往上调是不是就不会坏了。在后来的工作当中，我也是按照0到满占空比的比例慢慢给的，虽然这是以时间为代价的，但是这么做在新手阶段是值得的。</p><p>除了电源以为，自己也因为自己的不谨慎闯下了一些祸，比如说被电烙铁烫伤，没把电就去碰电源导致被电等等，这些不谨慎最后都是自己付出了代价。</p><h3 id="把握机遇"><a href="#把握机遇" class="headerlink" title="把握机遇"></a>把握机遇</h3><p>这里不好展开说说，等事成了在回来补。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT笔记(二)</title>
      <link href="/2023/11/30/QT%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
      <url>/2023/11/30/QT%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="信号槽基本使用和原理"><a href="#信号槽基本使用和原理" class="headerlink" title="信号槽基本使用和原理"></a>信号槽基本使用和原理</h2><p>信号和槽是QT中最重要的内容，在QT中各个组件的功能都是通过信号和槽函数进行操作的。</p><p>信号和槽就像FreeRTOS中信号量。信号函数只需要声明，不需要知道信号的接受者是谁（就像函数只需要放入信号量不需要知道是谁获取了信号），而槽函数则是只管接收，不需要知道是来自谁的信号（就像函数在获取信号量的时候只需要知道信号量中是否有数据并拿取不需要知道是谁放入的信号）。信号和槽之间的连接是通过对象进行绑定的。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>信号和槽函数的实现原理比较简单分为以下三步：</p><ol><li>绑定信号和槽函数</li><li>调用信号函数（将信号函数写入队列）</li><li>主线程中获取信号，并且获取信号对应的槽函数。</li></ol><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202311302310183.png" alt="信号和槽的关系"></p><h2 id="信号槽示例"><a href="#信号槽示例" class="headerlink" title="信号槽示例"></a>信号槽示例</h2><p>QT实现信号槽有两种方式：</p><blockquote><ol><li>在UI界面上有一个编辑信号槽，可以对控件编辑一些QT内部实现的信号槽，或者是信号槽界面进行编辑</li><li>手动添加信号槽</li></ol></blockquote><h3 id="UI界面添加信号槽"><a href="#UI界面添加信号槽" class="headerlink" title="UI界面添加信号槽"></a>UI界面添加信号槽</h3><p>在QT creator创建好项目之后，系统会同时创建一个界面文件，里面有一个.UI文件</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202311302320225.png" alt="界面文件"> </p><p>在UI界面的左侧可以看到有很多的控件，我们可以对里面的控件进行拖放。假设我们放入两个按钮，这两个按钮等会的功能一个是关闭窗口还有一个是最小化窗口。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202311302324101.png"></p><p>为了在后面能够更好的区分按钮的功能，可以在右侧属性栏中修改名称</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202312010001835.png"></p><p>在信号与槽的界面选择发送者、信号、接收者和槽</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202312010020122.png"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202312010022449.png"></p><h3 id="手动添加信号槽"><a href="#手动添加信号槽" class="headerlink" title="手动添加信号槽"></a>手动添加信号槽</h3><p>信号函数和槽函数在类中添加，信号函数和槽函数的返回值只能是void，只需要声明不需要实现，但是槽函数需要声明也需要实现。</p><p>添加信号函数以及槽函数之前需要在类中添加Q_OBJECT。如果不添加这个关键字那么系统不会识别类中的信号和槽函数。</p><p>创建信号函数使用的是 signals关键字，创建槽函数使用的函数是slots关键字。连接信号函数与槽函数使用的是connect函数。</p><p>之后只需要创建对象之后调用这个对象的信号，那么线程会自动根据信号函数调用对应的槽函数。槽函数在声明时使用slots必须选择范围（公开、保护、私有），但是信号函数可以不需要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow <span class="comment">//在类中声明信号和槽</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT  <span class="comment">// 必须要有</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line">signals:  <span class="comment">// 声明信号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">TEST</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> slots:  <span class="comment">//  声明槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>,<span class="built_in">SIGNAL</span>(TEST),<span class="keyword">this</span>,<span class="built_in">SLOT</span>(<span class="built_in">test</span>()));  <span class="comment">// 在构造函数中连接信号和槽函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::test</span><span class="params">()</span>  <span class="comment">// 类外定义槽函数，也可以在类内中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">showMinimized</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果需要调用那么使用<span class="keyword">new</span>创建一个MainWindow对象之后使用这个对象调用信号函数即可。</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="窗口基类QWidget"><a href="#窗口基类QWidget" class="headerlink" title="窗口基类QWidget"></a>窗口基类QWidget</h2><p>QWidget是所有用户界面的基类，包括鼠标键盘事件等等，同时他也可以在屏幕上绘制自己。</p><h3 id="相对坐标与绝对坐标"><a href="#相对坐标与绝对坐标" class="headerlink" title="相对坐标与绝对坐标"></a>相对坐标与绝对坐标</h3><p>绝对坐标：窗口相对于屏幕位置。屏幕左上角是（0，0），横轴X往左增大，纵轴Y往下增大。</p><p>相对坐标：子类位于父类的位置。</p><h3 id="手动创建QWidget对象"><a href="#手动创建QWidget对象" class="headerlink" title="手动创建QWidget对象"></a>手动创建QWidget对象</h3><p>引入QWidget头文件，使用QWidget w可以创建一个w对象，如果要显示窗口可以使用w.show();如果想隐藏窗口也可以使用w.hide();。</p><p>但是要注意的是QWidget创建对象要在创建QApplication对象后面创建，否则报错。创建QApplication对象的时候要引入Qwidgets&#x2F;QApllication头文件。</p><p>槽函数只能在主线程中调用不能在其他线程中调用如果其他线程要使用槽函数只能通过信号函数</p><h3 id="设置QWidget窗口坐标和尺寸"><a href="#设置QWidget窗口坐标和尺寸" class="headerlink" title="设置QWidget窗口坐标和尺寸"></a>设置QWidget窗口坐标和尺寸</h3>]]></content>
      
      
      <categories>
          
          <category> 上位机编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT、C++、上位机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于解决VSCode加载Platform一直loading插件安装不上的问题</title>
      <link href="/2023/10/15/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3VSCode%E5%8A%A0%E8%BD%BDPlatform%E4%B8%80%E7%9B%B4loading%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8D%E4%B8%8A%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/10/15/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3VSCode%E5%8A%A0%E8%BD%BDPlatform%E4%B8%80%E7%9B%B4loading%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8D%E4%B8%8A%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在学习使用ESP32，看了网上很多的IDE决定使用VSCODE+platform的组合进行ESP32的开发。</p><p>在第一步环境搭建的时候遇到platform一直在loading，重新打开的时候需要下载一个扩展也总是下载失败，如下图：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310152226252.png" alt="运行失败"></p><p>所以这两天一直摸索解决。</p><h1 id="网络方法汇总"><a href="#网络方法汇总" class="headerlink" title="网络方法汇总"></a>网络方法汇总</h1><p>在网上找到遇到这个问题的人很少，总结网上主要的解决方法：</p><ol><li><p>科学上网，这个由于platform的服务器在国外所以下载很慢，需要科学上网懂得都懂这里不展开说。</p></li><li><p>是因为本地的python环境原因，删掉就好了。</p><p> 第二种方法我看的是最多人说的方法，但是在我试过之后还是不行，这里说一下怎么删除本地的python环境，<strong>后面会用到</strong>。</p><p> 现在CMD下输入<code>where python</code>就能得到python的安装路径，这里可能会有几个这是正常的，现在很多软件的运行都依赖python。找到路径之后在环境变量中删除python路径即可。</p></li></ol><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>我是按照上面的方法也已经把python环境都删除了，<strong>在没有恢复的情况下</strong>，我们找到VSCODE下载platform的位置，我的是<code>C:\.platformio</code>也可以看报错信息里面有提示具体位置。（<em><strong>由于解决问题之前没有截取自己错误的信息，所以以上截图来自网络，根据上面的信息，platform的安装位置为“C：\Users\ldm\.platformio”</strong></em>）。</p><p>找到这个目录之后里面有一个python环境，在环境变量中添加这个环境。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310152239406.png"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310152246846.png"></p><p>之后再去下载就成功了，有条件的最好是科学网上，这样的速度会更快。</p>]]></content>
      
      
      <categories>
          
          <category> 解决问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP32、VSCODE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS快速入门（二）</title>
      <link href="/2023/09/24/FreeRTOS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/09/24/FreeRTOS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h1><p>同步与互斥主要是指在使用同一个资源的时候，一次只能由一个任务使用，后面的任务如果也想使用这个资源的时候只有等到前面的任务释放了这个资源才能使用。</p><p>常见的同步互斥的实现有：队列、任务通知、信号量、互斥量、事件组。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的使用"><a href="#队列的使用" class="headerlink" title="队列的使用"></a>队列的使用</h3><p>如果队列中没有数据，那么在读取这个队列的时候会进入到阻塞状态，直到队列中有数据为止。所以两个或以上的任务在抢夺相同资源的时候，可以将这个资源放入到队列中，如果拿到这个资源的任务先将队列清空，其他的任务等待这个资源直到这个任务完成的时候在将这个资源放入队列。</p><p>创建队列函数<code>QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )  </code></p><blockquote><p>uxQueueLength:指队列的长度</p><p>uxTtemSize:队列数据每个数据的大小</p><p>返回值：成功返回队列句柄，失败返回0</p></blockquote><p>队列的本质是一个环形缓冲区，在队列的内部有几个参数比较重要。</p><p><strong>队列参数：</strong></p><p><strong>1. pchead 指向buf首地址，指针的地址不会随着读取的位置变化而变化</strong></p><p><strong>2.pcreadfrom 上一次读地址的位置</strong></p><p><strong>3.pcwrite 上一次写的地址，默认情况下到队尾</strong></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle = xQueueCreate(<span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//创建一个存放1nt大小的队列</span></span><br></pre></td></tr></table></figure><p>在创建队列的时候，也可以传入结构体。</p><h3 id="队列写操作"><a href="#队列写操作" class="headerlink" title="队列写操作"></a>队列写操作</h3><p>写入数据时会拷贝itemsize大小的空间然后调整pcwirte指针的地址pcwrite +&#x3D; itemsize。如果队列写满的时候可以传入一个等待时间，如果不等待则立刻报错。在等待时间内会将任务放入xTaskwaitingTosend的队列，在等待时间后如果队列还是满的则报错。写满数据后pcwrite会在队列尾部跳转到头部。</p><p>写队列函数<code>BaseType_t xQueueSend(QueueHandle_t xQueue,const void *pvItemToQueue,TickType_t xTicksToWait)</code></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>xQueue</td><td>队列句柄</td></tr><tr><td>pvItemToQueue</td><td>写入队列的数据指针，</td></tr><tr><td>xTicksToWait</td><td>如果队列满的时候可以阻塞多长时间，如果传入portMAX_DELAY则表示等待可以等待的最长时间</td></tr></tbody></table><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xQueueSend(QueueHandle,&amp;a,portMAX_DELAY);  <span class="comment">// 传入变量a的地址到队列</span></span><br></pre></td></tr></table></figure><h3 id="队列读操作"><a href="#队列读操作" class="headerlink" title="队列读操作"></a>队列读操作</h3><p>读操作会将读到的数据放入buf中，如果没有数据会等待一段时间后报错，由于pcreadfrom指向的时上一次读的位置，所以在下一次读的时候pcreadfrom+&#x3D;itemsize，如果pcreadfrom到达列尾则下一次读时返回头部。</p><p>读队列函数：<code>BaseType_t xQueueReceive( QueueHandle_t xQueue,void * const pvBuffer,TickType_t xTicksToWait );  </code></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>xQueue</td><td>欲读取的队列的队列句柄</td></tr><tr><td>pvBuffer</td><td>将读到的数据放入到buffer中</td></tr><tr><td>xTicksToWait</td><td>如果队列为空的时候可以阻塞多长时间，如果传入portMAX_DELAY则表示等待可以等待的最长时间</td></tr></tbody></table><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xQueueReceive(QueueHandle,&amp;val,portMAX_DELAY);<span class="comment">//读取QueueHandle句柄的队列，并且将读取到的数据放入到val中，延迟时间portMAX_DELAY</span></span><br></pre></td></tr></table></figure><h3 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建两个任务，并且初始化传入一个默认的任务。task1和task2争抢队列资源，没有抢到的任务进行等到，抢到的任务获取队列中的数值并且打印该资源的值。执行完毕之后在完队列中传入一个数值。以便让其他任务调用。</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> rev;</span><br><span class="line"><span class="type">int</span> val =<span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1=<span class="number">1</span>;</span><br><span class="line">flag2=<span class="number">0</span>;</span><br><span class="line">xQueueReceive(QueueHandle,&amp;rev,portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task1:%d\n&quot;</span>,rev);</span><br><span class="line">xQueueSend( QueueHandle,&amp;val,portMAX_DELAY);</span><br><span class="line">vTaskResume(Task2Handle);</span><br><span class="line">vTaskResume(Task3Handle);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">Task2</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="type">int</span> val2 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1=<span class="number">0</span>;</span><br><span class="line">flag2=<span class="number">1</span>;</span><br><span class="line">xQueueReceive(QueueHandle,&amp;val,portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task2:%d\n&quot;</span>,val);</span><br><span class="line">xQueueSend(QueueHandle,&amp;val2,portMAX_DELAY);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">prvSetupHardware();</span><br><span class="line">QueueHandle = xQueueCreate(<span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// 创建队列</span></span><br><span class="line"><span class="keyword">if</span>(QueueHandle == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;queue is not create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">50</span>,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;Task1Handle);  <span class="comment">// 创建两个任务</span></span><br><span class="line">xTaskCreate(Task2,<span class="string">&quot;task2&quot;</span>,<span class="number">50</span>,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;Task2Handle);</span><br><span class="line">xQueueSend(QueueHandle,&amp;a,portMAX_DELAY);  <span class="comment">// 往队列中放入一个资源</span></span><br><span class="line"><span class="comment">//xTaskCreate(Task3,&quot;task3&quot;,50,NULL,1,NULL);</span></span><br><span class="line"><span class="comment">/* Start the scheduler. */</span></span><br><span class="line"></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Will only get here if there was not enough heap space to create the</span></span><br><span class="line"><span class="comment">idle task. */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309252342015.png" alt="输出结果"></p><h2 id="队列集"><a href="#队列集" class="headerlink" title="队列集"></a>队列集</h2><p>队列集中存放了不同的队列，比如键盘队列以及鼠标队列等等都可以放入到统称为用户的队列中。创建队列集的大小为所存放队列大小的总和，如A队列大小为3、B为4、C为5，如果将ABC中放入队列集中那么队列集的大小至少为12。</p><h4 id="队列集的使用"><a href="#队列集的使用" class="headerlink" title="队列集的使用"></a>队列集的使用</h4><p>如果很多队列都放入到队列集中那么应该怎么判断获取的队列是哪一个队列呢？这种解决方法可以往队列中传入数据时候传入一个数据结构，数据结构中包含name等成员，获取到这个队列的时候可以读取队列结构体进行判断。</p><p>创建队列集：<code>QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength );  </code></p><p>参考FreeRTOS手册：</p><blockquote><p>uxEventQueueLength:Queue sets store events that occur on the queues and semaphores contained in the set. uxEventQueueLength specifies the maximum number of events that can be queued at once. To be absolutely certain that events are not lost uxEventQueueLength must be set to the sum of the lengths of the queues added to the set, where binary semaphores and mutexes have a length of 1, and counting semaphores have a length set by their maximum count value. For example:  If a queue set is to hold a queue of length 5, another queue of length 12, and a binary semaphore, then uxEventQueueLength should be set to (5 + 12 + 1), or 18.</p></blockquote><p>说明创建队列集的参数选取的是队列大小的总和。</p><p>返回值</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>NULL</td><td>队列集创建失败</td></tr><tr><td>队列集句柄</td><td>队列集创建成功</td></tr></tbody></table><h4 id="队列集添加队列"><a href="#队列集添加队列" class="headerlink" title="队列集添加队列"></a>队列集添加队列</h4><p> 队列集添加队列的函数：<code>BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,QueueSetHandle_t xQueueSet );  </code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xQueueOrSemaphore</td><td>要添加到队列集的队列或信号量的句柄</td></tr><tr><td>xQueueSet</td><td>队列集句柄</td></tr></tbody></table><h4 id="获取队列集中的队列"><a href="#获取队列集中的队列" class="headerlink" title="获取队列集中的队列"></a>获取队列集中的队列</h4><p>获取队列集队列的函数<code>QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,const TickType_t xTicksToWait );  </code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xQueueSet</td><td>传入队列集的句柄</td></tr><tr><td>xTicksToWait</td><td>如果队列集空的时候可以阻塞多长时间，如果传入portMAX_DELAY则表示等待可以等待的最长时间</td></tr></tbody></table><p>使用xQueueSelectFromSet返回获取到的队列句柄，如果想获取队列里面的内容则需要在使用xQueueReceive获取（跟队列的操作一样）。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>前面的队列以及队列集可以携带信息给到另外一个任务，这里介绍的信号量只能进行任务通知，比如A任务执行完任务之后放入信号量来通知B任务，“我执行完了，你现在可以执行了！”。</p><p>信号量的本质是队列，但是信号量只能够表示资源数量，无法传输数据，放入信号量计数值+1，取出信号量计数量-1。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309262234920.png"></p><p>信号量分为：计数型信号量、二进制型信号量。</p><p>计数型信号量</p><ol><li>初始化时可以是任何值</li><li>使用give可以一直向上计数</li></ol><p>二进制型信号量</p><ol><li>初始化的时候值为0</li><li>只有两个计数值0和1</li></ol><h3 id="创建信号量"><a href="#创建信号量" class="headerlink" title="创建信号量"></a>创建信号量</h3><p>创建二进制型信号量：<code>SemaphoreHandle_t xSemaphoreCreateBinary( void );  </code></p><p>创建计数型信号量：<code>SemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount);  </code> </p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>uxMaxCount</td><td>最大的计数数量</td></tr><tr><td>uxInitialCount</td><td>技术型信号量的初始值</td></tr></tbody></table><p>返回信号量句柄。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphorecount = xSemaphoreCreateCounting(<span class="number">1</span>, <span class="number">0</span>);<span class="comment">// 创建计数型信号量，最大值为1，初始值为0，由此计数型信号量也可以模拟二进制型信号量</span></span><br></pre></td></tr></table></figure><h3 id="删除信号量"><a href="#删除信号量" class="headerlink" title="删除信号量"></a>删除信号量</h3><p>删除信号量函数：<code>void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );  </code></p><h3 id="信号量的使用（give-take）"><a href="#信号量的使用（give-take）" class="headerlink" title="信号量的使用（give&#x2F;take）"></a>信号量的使用（give&#x2F;take）</h3><p>放入信号量：<code>BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );  </code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>传入想要放入信号量的信号量句柄</td></tr></tbody></table><p>取出信号量：<code>BaseType_t xSemaphoreTake(SemaphoreHandle_t xSemaphore,TickType_t xTicksToWait);  </code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>想要取出信号量的信号量句柄</td></tr><tr><td>xTicksToWait</td><td>如果信号量的值为0则可以等待多长时间，如果传入portMAX_DELAY则表示等待可以等待的最长时间</td></tr></tbody></table><h3 id="综合示例-1"><a href="#综合示例-1" class="headerlink" title="综合示例"></a>综合示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t Task1Handle;</span><br><span class="line">TaskHandle_t Task2Handle;</span><br><span class="line">SemaphoreHandle_t SemaphoreHandle;</span><br><span class="line">QueueHandle_t semaphorecount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">xSemaphoreTake(SemaphoreHandle,  portMAX_DELAY);  <span class="comment">// 获取信号量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Task1:\n&quot;</span>);</span><br><span class="line">xSemaphoreGive(SemaphoreHandle);  <span class="comment">// 放入信号量</span></span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">Task2</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">xSemaphoreTake(SemaphoreHandle,  portMAX_DELAY);  <span class="comment">// 获取信号量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Task2:\n&quot;</span>);</span><br><span class="line">xSemaphoreGive(SemaphoreHandle);  <span class="comment">// 放入信号量</span></span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">prvSetupHardware();</span><br><span class="line">SemaphoreHandle = xSemaphoreCreateCounting(<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// 创建计数型信号量</span></span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">50</span>,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;Task1Handle);</span><br><span class="line">xTaskCreate(Task2,<span class="string">&quot;task2&quot;</span>,<span class="number">50</span>,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;Task2Handle);</span><br><span class="line">xSemaphoreGive(SemaphoreHandle);  <span class="comment">// 初始化放入一个值</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"><span class="comment">/* Will only get here if there was not enough heap space to create the</span></span><br><span class="line"><span class="comment">idle task. */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309262306480.png" alt="运行结果"></p><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>使用信号量的时候需要保证在A任务获得了资源后，B任务等待A执行结束放入资源。但是此时出现了一个C任务give信号量，导致在A任务执行期间B任务也开始执行导致与我们预想的AB只有一个执行不同。所以解决的措施是要谁上锁谁解锁，不能交由第三方。</p><p>在了解互斥量之前先了解两个概念：优先级继承、优先级反转。</p><h3 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h3><p>设想这样的一个场景，在使用信号量的时候假设有三个任务他们有着不同的优先级，A：1、B：2、C：3，并且A和C使用的是同一把锁A先执行获得锁。在A获取锁还么有释放的时候，B任务执行，由于B的优先级大于A 则B任务一直执行导致A任务跟优先级更高的C任务都不能够执行，这种优先级低的任务比优先级高的任务先执行的例子就是优先级反转。</p><h3 id="优先级继承"><a href="#优先级继承" class="headerlink" title="优先级继承"></a>优先级继承</h3><p><strong>解决优先级反转的问题就是使用优先级继承。</strong></p><p>优先级继承是指：低优先级获得锁的时候高优先级为了能够获得锁执行，<strong>临时</strong>将低优先级的任务优先级提升，等待低优先级的任务执行完成并且高优先级能够获得资源，那么低优先级的任务恢复到原来的优先级。</p><h3 id="互斥量的使用"><a href="#互斥量的使用" class="headerlink" title="互斥量的使用"></a>互斥量的使用</h3><p>互斥量跟信号量最大的不同点在于互斥量能够解决上述优先级反转的问题。获得互斥量的任务能够进行优先级继承。</p><p>互斥量的值与二进制信号量一样只有0跟1。</p><h4 id="创建互斥量"><a href="#创建互斥量" class="headerlink" title="创建互斥量"></a>创建互斥量</h4><p>创建互斥量的函数：<code>SemaphoreHandle_t xSemaphoreCreateMutex( void );  </code></p><p>创建互斥量返回信号句柄。</p><h4 id="互斥量的其他操作"><a href="#互斥量的其他操作" class="headerlink" title="互斥量的其他操作"></a>互斥量的其他操作</h4><p>互斥量在删除、Give和Take上与信号量一样。使用以下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;  <span class="comment">// 删除互斥量</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;  <span class="comment">// 放入互斥量</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(SemaphoreHandle_t xSemaphore,TickType_t xTicksToWait)</span>;  <span class="comment">// 获取互斥量</span></span><br></pre></td></tr></table></figure><h4 id="互斥量的使用案例"><a href="#互斥量的使用案例" class="headerlink" title="互斥量的使用案例"></a>互斥量的使用案例</h4><p>下面对使用互斥量和信号量进行一个对比：</p><p><strong>不使用互斥量的时候：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t Task1Handle;</span><br><span class="line">TaskHandle_t Task2Handle;</span><br><span class="line">TaskHandle_t Task3Handle;</span><br><span class="line">SemaphoreHandle_t semaphore_Handle ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> ch, FILE *f )</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> * param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1 = <span class="number">1</span>;</span><br><span class="line">flag2 = <span class="number">0</span>;</span><br><span class="line">flag3 = <span class="number">0</span>;</span><br><span class="line">xSemaphoreTake(semaphore_Handle, portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task1&quot;</span>);</span><br><span class="line">xSemaphoreGive(semaphore_Handle);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task2</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//vTaskDelay(6);</span></span><br><span class="line">xSemaphoreTake(semaphore_Handle, portMAX_DELAY);</span><br><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line">flag2 = <span class="number">1</span>;</span><br><span class="line">flag3 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task2&quot;</span>);</span><br><span class="line">xSemaphoreGive(semaphore_Handle);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task3</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//vTaskDelay(5);</span></span><br><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line">flag2 = <span class="number">0</span>;</span><br><span class="line">flag3 = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task3&quot;</span>);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">prvSetupHardware();</span><br><span class="line"></span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task1Handle);</span><br><span class="line">xTaskCreate(Task2,<span class="string">&quot;task2&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">3</span>,&amp;Task2Handle);</span><br><span class="line">xTaskCreate(Task3,<span class="string">&quot;task3&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">2</span>,&amp;Task3Handle);</span><br><span class="line">semaphore_Handle = xSemaphoreCreateBinary(); <span class="comment">// 使用信号量</span></span><br><span class="line">xSemaphoreGive(semaphore_Handle);</span><br><span class="line"><span class="comment">/* Start the scheduler. */</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310050037189.png" alt="不使用互斥量的时候"></p><p><strong>使用互斥量的时候：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t Task1Handle;</span><br><span class="line">TaskHandle_t Task2Handle;</span><br><span class="line">TaskHandle_t Task3Handle;</span><br><span class="line">SemaphoreHandle_t semaphore_Handle ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> ch, FILE *f )</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> * param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1 = <span class="number">1</span>;</span><br><span class="line">flag2 = <span class="number">0</span>;</span><br><span class="line">flag3 = <span class="number">0</span>;</span><br><span class="line">xSemaphoreTake(semaphore_Handle, portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task1&quot;</span>);</span><br><span class="line">xSemaphoreGive(semaphore_Handle);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task2</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//vTaskDelay(6);</span></span><br><span class="line">xSemaphoreTake(semaphore_Handle, portMAX_DELAY);</span><br><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line">flag2 = <span class="number">1</span>;</span><br><span class="line">flag3 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task2&quot;</span>);</span><br><span class="line">xSemaphoreGive(semaphore_Handle);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task3</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//vTaskDelay(5);</span></span><br><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line">flag2 = <span class="number">0</span>;</span><br><span class="line">flag3 = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task3&quot;</span>);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">prvSetupHardware();</span><br><span class="line"></span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task1Handle);</span><br><span class="line">xTaskCreate(Task2,<span class="string">&quot;task2&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">3</span>,&amp;Task2Handle);</span><br><span class="line">xTaskCreate(Task3,<span class="string">&quot;task3&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">2</span>,&amp;Task3Handle);</span><br><span class="line">semaphore_Handle = xSemaphoreCreateMutex();</span><br><span class="line">xSemaphoreGive(semaphore_Handle);</span><br><span class="line"><span class="comment">/* Start the scheduler. */</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310050031233.png" alt="实现优先级继承"></p><p>根据上面的现象可以看到，使用互斥量的时候可以实现优先级的继承使得任务二也能够得到执行。</p><h4 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h4><p>设想以下的画面，如果函数A获得了互斥量M1，在A的函数里面又调用了另外一个函数B，但是函数B里面也需要使用M1，此时A要等待B运行完才能运行，但是M1又在A手中，B需要M1才能执行。所以就造成了递归锁。</p><p>解决上述递归死锁的方法：</p><ol><li>避免在函数里面调用其他的会进入阻塞状态的函数。</li><li>使用递归锁，解决锁只用获取一次，即使调用的函数需要使用这个互斥量也能够获得锁。</li></ol><h5 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h5><p>创建递归锁函数：<code>SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void );</code></p><p>返回值是SemaphoreHandle_t </p><h5 id="获得递归锁"><a href="#获得递归锁" class="headerlink" title="获得递归锁"></a>获得递归锁</h5><p>获得递归锁的函数：<code>BaseType_t xSemaphoreTakeRecursive(SemaphoreHandle_t xSemaphore,TickType_t xTicksToWait); </code></p><h5 id="释放递归锁"><a href="#释放递归锁" class="headerlink" title="释放递归锁"></a>释放递归锁</h5><p>释放递归锁的函数：<code>BaseType_t xSemaphoreGiveRecursive( SemaphoreHandle_t xSemaphore );  </code></p><h5 id="递归锁案例"><a href="#递归锁案例" class="headerlink" title="递归锁案例"></a>递归锁案例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t Task1Handle;</span><br><span class="line">SemaphoreHandle_t xSemaphore;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> ch, FILE *f )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sub_Task1</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">xSemaphoreTakeRecursive(xSemaphore, portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is sub_task1\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> * param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">xSemaphoreTakeRecursive(xSemaphore, portMAX_DELAY);</span><br><span class="line">Sub_Task1(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is task1\n&quot;</span>);</span><br><span class="line">xSemaphoreGiveRecursive(xSemaphore);</span><br><span class="line">vTaskDelay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">prvSetupHardware();</span><br><span class="line"></span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task1Handle);</span><br><span class="line"></span><br><span class="line">xSemaphore = xSemaphoreCreateRecursiveMutex();</span><br><span class="line"><span class="comment">/* Start the scheduler. */</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310050103570.png" alt="运行结果"></p><p><em><strong>如果将上述的递归锁换成互斥量，那么将出现卡死现象</strong></em></p><h2 id="事件组"><a href="#事件组" class="headerlink" title="事件组"></a>事件组</h2><p>事件组可以在等到个别任务全部完成或等到某几个指定的任务完成之后才执行另外一个任务。例如吃饭任务需要等待买菜，买厨具，做饭，摆桌等全部的任务执行完成之后才能够执行吃饭的任务。</p><p>事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。  如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件，如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件。<br>configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑，如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位，如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310021436909.png"></p><h3 id="创建-删除事件组"><a href="#创建-删除事件组" class="headerlink" title="创建&#x2F;删除事件组"></a>创建&#x2F;删除事件组</h3><p>创建事件组使用的函数是<code>EventGroupHandle_t xEventGroupCreate( void );  </code>返回值是事件组句柄。如果创建失败则返回NULL。</p><p>删除事件组使用的函数是<code>void vEventGroupDelete( EventGroupHandle_t xEventGroup );</code>传入的参数是欲删除的事件组句柄。</p><h3 id="设置事件组"><a href="#设置事件组" class="headerlink" title="设置事件组"></a>设置事件组</h3><p>在某个任务完成之后可以设置某个事件的标志位例如A任务完成之后需要置bit0，bit9位为1。如果后面的任务需要判断A函数是否执行完成，就可以判断事件组中的第0和9位是否置1，如果置1那么表示A事件执行完成。</p><p>设置事件组的函数<code>EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,const EventBits_t uxBitsToSet )</code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xEventGroup</td><td>需要放置的事件句柄</td></tr><tr><td>uxBitsToSet</td><td>需要设置的位，例如传入0X09，表示置bit0，bit3位为1</td></tr></tbody></table><h3 id="等待事件组"><a href="#等待事件组" class="headerlink" title="等待事件组"></a>等待事件组</h3><p>跟前面的队列，互斥量、信号量类似，有人放就有人拿。有人放置事件组，那么就应该有相应的任务D等待事件组，该任务D等到事件组满足条件之后，D才能够执行。</p><p>等待事件组的函数是<code>EventBits_t xEventGroupWaitBits( const EventGroupHandle_t xEventGroup,const EventBits_t uxBitsToWaitFor,const BaseType_t xClearOnExit,const BaseType_t xWaitForAllBits,TickType_t xTicksToWait);</code>等待事件组可以是等待某一个位，也可以是等待多个位、也可以清除某些位。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xEventGroup</td><td>要等待的事件组句柄。</td></tr><tr><td>uxBitsToWaitFor</td><td>要等待的位，可以是十六进制如0x15，或则是某两个位的或值。</td></tr><tr><td>xClearOnExit</td><td>事件组满足条件之后，执行完等待指令是否要清除uxBitsToWaitFor中的位，pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除。</td></tr><tr><td>xWaitForAllBits</td><td>是否等待uxBitsToWaitFor所有的位，pdTRUE：等待所有的位 pdFALSE：等待uxBitsToWaitFor某一位。</td></tr><tr><td>xTicksToWait</td><td>等待时间。</td></tr></tbody></table><p><code>xClearOnExit</code>参数如果设置位pdFalse，那么在执行完函数等待事件函数的时候相应的位不会被清除，后续如果想清除可以使用<code>EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,const EventBits_t uxBitsToClear );</code>函数清除，但是在等待事件和清除函数之间可能被其他的任务打断然后写入新的位，后面在执行清除操作的时候就会发生误差&#x2F;错误。所以想要清除位在等待事件函数中清除可以减少原子性。</p><h3 id="等待事件组案例"><a href="#等待事件组案例" class="headerlink" title="等待事件组案例"></a>等待事件组案例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t Task1Handle;</span><br><span class="line">TaskHandle_t Task2Handle;</span><br><span class="line">TaskHandle_t Task3Handle;</span><br><span class="line">SemaphoreHandle_t xSemaphore;</span><br><span class="line">EventGroupHandle_t EventHandle;</span><br><span class="line"><span class="type">uint16_t</span> flag1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint16_t</span> flag3 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> ch, FILE *f )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> * param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1 = <span class="number">1</span>;</span><br><span class="line">flag2 = <span class="number">0</span>;</span><br><span class="line">flag3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">xEventGroupSetBits(EventHandle,<span class="number">0x06</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task1 final\n&quot;</span>);</span><br><span class="line">vTaskDelay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task2</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line">flag2 = <span class="number">1</span>;</span><br><span class="line">flag3 = <span class="number">0</span>;</span><br><span class="line">xEventGroupSetBits(EventHandle,<span class="number">0x09</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task2 final\n&quot;</span>);</span><br><span class="line">vTaskDelay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task3</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag1 = <span class="number">0</span>;</span><br><span class="line">flag2 = <span class="number">0</span>;</span><br><span class="line">flag3 = <span class="number">1</span>;</span><br><span class="line">xEventGroupWaitBits(EventHandle,<span class="number">0x0F</span>,pdTRUE,pdTRUE,portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;finally all\n&quot;</span>);</span><br><span class="line">vTaskDelay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">prvSetupHardware();</span><br><span class="line"></span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task1Handle);</span><br><span class="line">xTaskCreate(Task2,<span class="string">&quot;task2&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task2Handle);</span><br><span class="line">xTaskCreate(Task3,<span class="string">&quot;task3&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task3Handle);</span><br><span class="line">EventHandle = xEventGroupCreate();</span><br><span class="line">xSemaphore = xSemaphoreCreateRecursiveMutex();</span><br><span class="line"><span class="comment">/* Start the scheduler. */</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310050137417.png" alt="运行结果"></p><h3 id="同步点"><a href="#同步点" class="headerlink" title="同步点"></a>同步点</h3><p>同步点主要是服务于有一个事件需要多个任务同步完成，大家都完成之后才能够执行同一件事。</p><p>例如一共有三个人：</p><ul><li>A：准备食材</li><li>B：去买酒</li><li>C：做饭</li></ul><p>A、B、C只有等到上述所有的事都做完之后才能吃饭，所以吃饭时三个任务的同步点。</p><h4 id="同步点使用"><a href="#同步点使用" class="headerlink" title="同步点使用"></a>同步点使用</h4><p>创建同步点函数<code>EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,const EventBits_t uxBitsToSet,const EventBits_t uxBitsToWaitFor,TickType_t xTicksToWait );  </code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xEventGroup</td><td>同步的事件组</td></tr><tr><td>uxBitsToSet</td><td>想要设置的事件组的位</td></tr><tr><td>uxBitsToWaitFor</td><td>想要等待的事件组的位</td></tr><tr><td>xTicksToWait</td><td>可以等待的时间</td></tr></tbody></table><h4 id="同步点案例"><a href="#同步点案例" class="headerlink" title="同步点案例"></a>同步点案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">EventGroupHandle_t EventHandle;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Retargets the C library printf function to the USART.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> ch, FILE *f )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Configures the timers and interrupts for the fast interrupt test as</span></span><br><span class="line"><span class="comment"> * described at the top of this file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Task1</span><span class="params">(<span class="type">void</span> * param)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">xEventGroupSync(EventHandle, <span class="number">0x01</span>, <span class="number">0x07</span>, portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;All task has completed ,task1 running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task2</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">xEventGroupSync(EventHandle, <span class="number">0x02</span>, <span class="number">0x07</span>, portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;All task has completed ,task2 running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Task3</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">xEventGroupSync(EventHandle, <span class="number">0x04</span>, <span class="number">0x07</span>, portMAX_DELAY);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;All task has completed ,task3 running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">  debug();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">prvSetupHardware();</span><br><span class="line"></span><br><span class="line">xTaskCreate(Task1,<span class="string">&quot;task1&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task1Handle);</span><br><span class="line">xTaskCreate(Task2,<span class="string">&quot;task2&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task2Handle);</span><br><span class="line">xTaskCreate(Task3,<span class="string">&quot;task3&quot;</span>,<span class="number">20</span>,<span class="literal">NULL</span>,<span class="number">1</span>,&amp;Task3Handle);</span><br><span class="line">EventHandle = xEventGroupCreate();</span><br><span class="line"><span class="comment">/* Start the scheduler. */</span></span><br><span class="line">vTaskStartScheduler();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310052123700.png" alt="运行结果"></p><h2 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h2><p>任务通知与队列、互斥量、事件组等等不同，任务通知适用于一对一的任务通信，其中一个任务通知另一个任务以触发特定操作。通知通常用于低延迟的通信和同步需求，例如在生产者-消费者问题中使用。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310032135089.png" alt="使用队列、事件组"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202310032135976.png" alt="使用任务通知"></p><p>任务通知的优势：</p><ol><li>效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都<br> 有大的优势。</li><li>更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。</li></ol><p>任务通知的限制：</p><ol><li>不能发送数据给ISR：<br> ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。</li><li>数据只能给该任务独享<br> 使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。</li><li>无法缓冲数据<br> 使用队列时，假设队列深度为N，那么它可以保持N个数据。使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。</li><li>无法广播给多个任务<br> 使用事件组可以同时给多个任务发送事件。使用任务通知，只能发个一个任务。</li><li>如果发送受阻，发送方无法进入阻塞状态等待<br> 假设队列已经满了，使用 xQueueSendToBack() 给队列发送数据时，任务可以进入阻塞状态等待<br> 发送完成。使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。</li></ol><h3 id="放入-取出数值"><a href="#放入-取出数值" class="headerlink" title="放入\取出数值"></a>放入\取出数值</h3><p>放入任务通知资源以及的函数一共有两种，一种是简约版本的函数，还有一种高级版本的函数。</p><p>简约版放入函数：<code>BaseType_t xTaskNotifyGive( TaskHandle_t );</code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xTaskToNotify</td><td>需要通知的任务句柄</td></tr></tbody></table><p>简约版取出函数：<code>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait);</code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xClearCountOnExit</td><td>在函数执行完成退出的时候是否清零</td></tr><tr><td>xTicksToWait</td><td>等待任务通知的时间</td></tr></tbody></table><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS快速入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS快速入门（一）</title>
      <link href="/2023/09/10/FreeRTOS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/09/10/FreeRTOS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要引入FreeRTOS"><a href="#为什么要引入FreeRTOS" class="headerlink" title="为什么要引入FreeRTOS"></a>为什么要引入FreeRTOS</h2><p>设想这样的场景，如果一个人需要打扫卫生，有需要写作业。这两件事的优先级是同样的。在裸机开发中面对这样的场景，如果是按照线性的方式进行程序编写如先写作业在打扫卫生或者是先打扫卫生，可能都会因为前面的任务执行的时间很长而耽误了另外一个任务的执行。（<em><strong>注：在裸机中减少任务运行时间的最好办法是使用状态机</strong></em>）。</p><p>那有没有能够“同时”执行这两种任务的方法呢？我们可以规定一个时间片，假设这个时间片是一秒，那么每隔一秒钟就切换一次任务，刚开始执行写作业的时候就开始计时，一秒钟一到就切换成打扫卫生。这样就能两个任务都将兼顾了。这就是FREERTOS的运行机制。在一些需要实时性比较强的系统中都会引入RTOS操作系统。</p><h2 id="FREERTOS结构分析及环境配置"><a href="#FREERTOS结构分析及环境配置" class="headerlink" title="FREERTOS结构分析及环境配置"></a>FREERTOS结构分析及环境配置</h2><p>FreeRTOS的下载地址：<a href="https://www.freertos.org/zh-cn-cmn-s/a00104.html">https://www.freertos.org/zh-cn-cmn-s/a00104.html</a></p><p>下载的时候<strong>不要</strong>选择LTS版本的，<strong>应该</strong>选择带有示例源码的版本。如下：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309101636002.png"></p><p>下载完解压后的目录如下：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309102225437.png"></p><p>目录中只有FreeRTOS需要用到，其他的文件可以删除。</p><p>进去FreeRTOS后里面的文件包含</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309102227921.png"></p><ul><li>Demo文件主要是示例代码</li><li>source文件时FreeRTOS的核心文件</li><li>其他的文件可以删除</li></ul><p>在Demo文件夹中包含了很多的示例程序，找到使用的IDE以及使用的芯片示例即可，其余的可以删除（根据编译报错，有时候需要留下Demo文件中的common文件夹。他是独立于Demo文件的独立文件）。</p><p>在source文件夹中，主要有一个protable文件夹，里面包含了移植文件时需要实现的参数函数。里面有各个IDE编译器的架构以及内存管理（MemMang）。留下需要的架构以及内存管理，剩下的可以删除。</p><p>MemMang文件夹中，包含heap_1\2\3\4\5，表示了5种不同的内存空间管理方法。</p><table><thead><tr><th>文件</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>heap_1</td><td>分配简单，时间确定</td><td>只分配、不回收</td></tr><tr><td>heap_2</td><td>动态分配、最佳匹配</td><td>碎片、时间不定</td></tr><tr><td>heap_3</td><td>调用标准库函数</td><td>速度慢、时间不定</td></tr><tr><td>heap_4</td><td>相邻空闲内存可合并</td><td>可解决碎片问题、时间不定</td></tr><tr><td>heap_5</td><td>在heap_4基础上支持分隔的内存块</td><td>可解决碎片问题、时间不定</td></tr></tbody></table><p>需要使用哪一种内存管理方式，只需要将相应的堆加载到程序中即可。</p><p>以下将使用keil-STM32F10x系列文件结构，将示例程序中示例代码进行删除和修改之后得到的结构如图所示：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309102242984.png"></p><p>使用示例程序修改好模板之后可以通过多次编译查找错误位置的方式将没用的程序删除。</p><h2 id="FreeRTOS基础说明"><a href="#FreeRTOS基础说明" class="headerlink" title="FreeRTOS基础说明"></a>FreeRTOS基础说明</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在FreeRTOS中定义了两个常见的数据类型分别是<code>TickType_t</code>以及<code>Base_type_t</code></p><blockquote><p><code>TickTtpe_t</code>可以是16位也可以是32位的，这取决于在FreeRTOS.h中是否定义<code>configUSE_16_BIT_TICKS  </code>如果定义了这个变量那么<code>TickTtpe_t</code>就是uint16_t类型，否则就是uint32_t类型</p><p><code>BaseType_t</code>是什么样的数据类型主要取决于MCU是什么样的架构，如果在32位架构中那么就是uint32_t，在16位架构中就是uint16_t，在8位架构中就是uint8_t。</p></blockquote><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><h4 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h4><p>FreeRTOS的变量名的是有规律的<code>变量名 = 前缀 + 含义</code></p><p>变量前缀：</p><table><thead><tr><th>前缀</th><th>含义</th></tr></thead><tbody><tr><td>x</td><td>Base_type_t 类型：结构体、任务句柄等等</td></tr><tr><td>c</td><td>char</td></tr><tr><td>s</td><td>int16_t</td></tr><tr><td>l</td><td>int32_t</td></tr><tr><td>u</td><td>unsigned</td></tr><tr><td>p</td><td>指针</td></tr><tr><td>uc</td><td>uint8_t</td></tr><tr><td>pc</td><td>char指针</td></tr></tbody></table><p>例如变量名：<code>xTaskToSuspend</code> 任务暂停变量，根据前缀x可以判断这个变量时Bse_type_t类型后面为变量的含义任务暂停</p><h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><p>函数名的命名规则主要是遵守：<code>函数名 = 返回类型+函数所在文件名+含义</code></p><p>例如创建任务的函数：xTaskCreate表示该函数的返回值为BaseType_t这个函数在Task.c文件中，作用是创建函数。</p><p><code>pvTimerGetTimerID</code>表示返回类型是void指针类型，在Timer文件中，作用是获取时间的ID</p><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><p>宏的名字可以在前面加上前缀表示这个宏在哪个文件中</p><table><thead><tr><th>宏前缀</th><th>文件</th></tr></thead><tbody><tr><td>port</td><td>portable.h</td></tr><tr><td>task</td><td>task.h</td></tr><tr><td>pd</td><td>projdefs.h</td></tr><tr><td>config</td><td>FreerRTOSConfig.h</td></tr><tr><td>err</td><td>projdefs.h</td></tr></tbody></table><p>例如：<code>portMAX_DELAY</code>表示这个宏在protable.h文件中</p><p><code>pdTRUE</code>表示这个宏在projdefs.h文件中。</p><p>通用的宏定义;</p><table><thead><tr><th>宏</th><th>含义</th></tr></thead><tbody><tr><td>pdTRUE</td><td>1</td></tr><tr><td>pdFALSE</td><td>0</td></tr><tr><td>pdPASS</td><td>1</td></tr><tr><td>pdFAIL</td><td>0</td></tr></tbody></table><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>在FreeRTOS中，任务就是函数，在执行任务时就是去执行创建任务时传入的函数指针。</p><p>在FreeRTOS中创建任务使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xTaskCreate(TaskFunction_t pxTaskCode,<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth,<span class="type">void</span> * <span class="type">const</span> pvParameters, UBaseType_t uxPriority, TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span><br></pre></td></tr></table></figure><table><thead><tr><th>变量</th><th>作用</th></tr></thead><tbody><tr><td>pxTaskCode</td><td>函数指针</td></tr><tr><td>pcName</td><td>任务名</td></tr><tr><td>usStackDepth</td><td>栈深度</td></tr><tr><td>pvParameters</td><td>传入函数的参数</td></tr><tr><td>uxPriority</td><td>任务的优先级</td></tr><tr><td>pxCreatedTask</td><td>任务句柄</td></tr></tbody></table><p>返回值：如果创建任务成功放回pdPass，任务创建失败返回errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY（-1）</p><p>创建失败的原因大部分是因为内存不足导致。</p><h4 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h4><p>优先级越高的任务优先执行，在FreeRTOS优先级取值范围为：0~(configMAX_PRIORITIES – 1)  ，值越高则任务优先级越高。</p><p>对于优先级相同的任务轮流执行。</p><h4 id="栈分配"><a href="#栈分配" class="headerlink" title="栈分配"></a>栈分配</h4><p>分配内存的时，在堆区会先创建一个头部，这个头部是一个至少包含了数据长度信息的结构体，并返回这个空间的首地址，在释放空间的时候首地址向前推得到数据的长度，从而确定需要释放的空间大小。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309241446349.png"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309241451834.png"></p><h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><p>删除任务使用的函数是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vTaskDelete(TaskHandle_t xTaskToDelete)</span><br></pre></td></tr></table></figure><p>删除任务的时候需要传入任务的句柄，任何任务都能够删除其他的任务，如果删除的任务传入的是NULL则表示任务自杀。</p><h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p>任务状态除了运行态以外，也有非运行态，但是非运行态也包含阻塞状态、暂停态、就绪态三种。</p><p>这三种非运行状态在不同场景下执行。</p><p>进入暂停状态可以是其他任务指定它为暂停状态也可以是自身进入暂停状态。但是如果要唤醒暂停状态的任务则需要别的任务进行唤醒或者是中断程序唤醒。</p><p>就绪状态是等待下一次运行的任务，他们不需要用函数调用和唤醒执行。等待时间片到达之后执行即可。</p><p>阻塞状态是被动进入状态的，在等待事件的时候不会消耗CPU，等到事件到来之后才被唤醒。这个事件可以是延迟函数、也可以是信号量，队列等等。</p><p>进入暂停状态使用VTasksuspend，但是如果要唤醒进入暂停的任务则需要其他任务执行vTaskResume来将任务唤醒。</p><p>三种状态的状态转换图如下：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309171831581.png"></p><h3 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h3><p>在FreeRTOS中有两个常用的延迟函数：</p><p><code>vTaskDelay</code>等待指定时间之后任务从阻塞状态编程就绪状态</p><p><code>vTaskDelayUntil</code>等待绝对时长之后变成就绪状态</p><h3 id="空闲空间"><a href="#空闲空间" class="headerlink" title="空闲空间"></a>空闲空间</h3><p>空闲任务主要用于清理被删除的任务，释放空间。由于空闲任务的优先级为0，所以空闲任务不能进入阻塞和暂停状态，并且空闲任务执行的时间不能过长。</p><p>空闲任务在开启任务的时候就会自动调用空闲任务，如果我们需要在空闲任务中添加任务，不需要自己写空闲任务，在空闲任务中提供了一个钩子函数<code>vApplicationIdleHook  </code>。在使用这些函数的时候需要注意宏定义，有一些函数需要在定义宏之后才能使用，否则不能执行报错。调用钩子函数的时候不能使用while(1)以防空闲任务有其他的任务要做。</p><p><strong>由于空闲任务的优先级是0，空闲任务的优先级最低但是空闲任务确实很重要的，所以要保证空闲任务有执行的机会，如果其他二任务优先级都比空闲任务高并且这些任务都不进入阻塞或暂停状态，那么空闲任务将没有机会得到执行，那么删除任务之后被删除的任务的空间将得不到释放，在后续的执行中有可能空间不足导致系统奔溃。</strong></p><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>调度策略的配置一共有3中配置，一般是在FreeRTOSConfig.h文件中</p><blockquote><ol><li>可否抢占优先级（configUSE_PREEMPTION）<ol><li>可以抢占，则高优先级先执行</li><li>不可以，则高优先级不能抢占资源，只能能等待前面的任务执行完成之后才可以</li></ol></li><li>可以抢占优先级的前提下，同优先级是否支持时间片轮转（configUSE_TIME_SLICING）：<ol><li>支持时间片轮流：表示相同优先级的任务轮流执行，每个任务执行一个时间片</li><li>不支持时间片轮转：表示同个优先级的任务不能轮流执行，前面一个任务一直执行直到该任务主动放弃或高优先级抢占为止。</li></ol></li><li>在可以抢占优先级+支持时间片轮转的情况下空闲任务是否让步于用户任务（configIDLE_SHOULD_YIELD）：<ol><li>空闲任务主动让步于用户任务：表示在相同优先级的情况下空闲任务只有等到其他任务执行完成或者主动放弃执行为止空闲任务才能够执行</li><li>不让步于用户任务：则表示空闲任务会争夺相同优先级任务的执行权。</li></ol></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS快速入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用HEXO以及Github搭建博客</title>
      <link href="/2023/08/27/%E4%BD%BF%E7%94%A8HEXO%E4%BB%A5%E5%8F%8AGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/08/27/%E4%BD%BF%E7%94%A8HEXO%E4%BB%A5%E5%8F%8AGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="工欲善其事"><a href="#工欲善其事" class="headerlink" title="工欲善其事"></a>工欲善其事</h1><h2 id="Git下载及配置"><a href="#Git下载及配置" class="headerlink" title="Git下载及配置"></a>Git下载及配置</h2><p>电脑中需要安装git，没有git中可以在<a href="https://git-scm.com/downloads">官网</a>中下载。安装的时候一路next即可，也可以选择自己要安装的目录。</p><p>安装好git后，打开Git Bash(如图)</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271539904.png" alt="Git Bash"></p><p>然后使用以下git命令绑定账号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;github中的用户名&quot;</span><br><span class="line">git config --global user.emil &quot;github绑定的邮箱&quot;</span><br></pre></td></tr></table></figure><h2 id="Nose-JS下载"><a href="#Nose-JS下载" class="headerlink" title="Nose.JS下载"></a>Nose.JS下载</h2><p>hexo是基于Nose.js框架下驱动的，所以使用hexo创建网站的时候需要下载（Nose.js)[<a href="https://nodejs.org/en/download]%E6%A1%86%E6%9E%B6%E3%80%82">https://nodejs.org/en/download]框架。</a></p><p>以上步骤完成之后，可以使用<em>git -version</em>或者<em>npm -v</em>进行测试。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271553490.png" alt="测试下载"></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>在git中输入<em><strong>npm install -g hexo-cli</strong></em>下载hexo</p><h2 id="在github中创建静态网站的仓库"><a href="#在github中创建静态网站的仓库" class="headerlink" title="在github中创建静态网站的仓库"></a>在github中创建静态网站的仓库</h2><p>每一个账号都只能有一个repo个人主页，并且这个网站要放在maser分支上。在github中创建一个仓库，这个仓库的名字有严格的要求，格式为：&#x3D;&#x3D;用户名&#x2F;用户名.gothub.io&#x3D;&#x3D;，例如：xiaobini&#x2F;xiaobini.github.io，这里的用户名是Github的用户名，必须是Github用户名。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271607646.png" alt="仓库创建"></p><h1 id="利剑出鞘"><a href="#利剑出鞘" class="headerlink" title="利剑出鞘"></a>利剑出鞘</h1><h2 id="使用HEXO生成原始网站"><a href="#使用HEXO生成原始网站" class="headerlink" title="使用HEXO生成原始网站"></a>使用HEXO生成原始网站</h2><p>在任意位置右键打开Git Bash或者是使用cd指令进入，总之命令行要指向该窗口，我将博客的文件存放到D:\myblog中。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271625942.png"></p><p>然后在git中分别执行下面指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init blog  #这里的blog可以是你自己喜欢的名字</span><br><span class="line">cd blog</span><br><span class="line">nmp install</span><br></pre></td></tr></table></figure><p>如果上面指令都没有出错的话，可以输入 hexo s启动服务，然后在<a href="http://localhost:4000/">http://localhost:4000</a> 中可以看到该网站的最初形态。</p><h2 id="加载主题"><a href="#加载主题" class="headerlink" title="加载主题"></a>加载主题</h2><p>关于hexo中的各个主题可以在<a href="https://hexo.io/themes/index.html">hexo主题</a>中获得，下面就以<a href="https://github.com/blinkfox/hexo-theme-matery">matery</a>为例。</p><p>绝大多数主题作者都会告诉安装以及配置方式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/blinkfox/hexo-theme-matery.git # 使用该指令下载主题</span><br></pre></td></tr></table></figure><p>打开博客根目录（D:\Myblog\blog），找到_config.yml，打开后拉到最后找到theme。将landscpe替换成主题名字。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271759461.png" alt="主题配置1"></p><p>下载后将主题放置到hexo生成文件中的themes文件夹（D:\Myblog\blog\themes）中。这个时候在git中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 更新生成</span><br><span class="line">hexo s # 开启服务</span><br></pre></td></tr></table></figure><p>这个时候再打开<a href="http://localhost:4000/">http://localhost:4000</a> 就能看到主题。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>打开主题文件夹（D:\Myblog\blog\themes\hexo-theme-matery）找到_config.yml进行主题配置。</p><p>根据作者的描述，如果需要在网页中加上分类或者是标签的话需要在git中使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;tag&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271654345.png" alt="配置主题1"></p><p>输入后在博客目录的sorce文件夹下会分别生成tag、categories文件夹。这两个文件夹里面包含了index.md，打开后将头部修改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tag文件夹中的index.md加入</span></span><br><span class="line">title: tags</span><br><span class="line">date: 2018-09-30 18:23:38</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">categories文件夹中的index.md加入</span></span><br><span class="line">title: categories</span><br><span class="line">date: 2018-09-30 17:25:30</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271658498.png" alt="tag配置"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271700473.png" alt="categories配置"></p><p>以后在写文章的时候在文章的头部分别加入tag、categories就可以在网页中点击该栏目的时候看到这个文章。</p><p>关于其他的配置这里栏目的配置参照github中作者的配置。</p><p>自己需要的栏目配置好后，打开主题里面的__config.yml文件，进行配置。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271703854.png" alt="栏目配置"></p><p>关于其他的配置如音乐播放、背景图片、文字等等也都是在这个文档中进行配置，根据作者在这个文档中的注释进行配置。不在赘述。</p><p>配置好主题后重新输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 更新生成</span><br><span class="line">hexo s # 开启服务</span><br></pre></td></tr></table></figure><p>即可在<a href="http://localhost:4000/">http://localhost:4000</a> 查看网页配置的情况。</p><h2 id="博客部署到Github上"><a href="#博客部署到Github上" class="headerlink" title="博客部署到Github上"></a>博客部署到Github上</h2><h3 id="SSH-Key配置"><a href="#SSH-Key配置" class="headerlink" title="SSH Key配置"></a>SSH Key配置</h3><p>在git中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;</span><br><span class="line">ssh-keygen -t rsa -C &#x27;上面的邮箱&#x27;</span><br></pre></td></tr></table></figure><p>根据提示三次回车后生成ssh key。</p><p>之后再git中使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>查看ssh密钥，复制这个密钥打开github，在Settings中找到 SSH and GPG keys。点击Nnew SSH Key。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271719546.png" alt="github ssh配置"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271721704.png" alt="SSH 配置"></p><h3 id="根目录配置"><a href="#根目录配置" class="headerlink" title="根目录配置"></a>根目录配置</h3><p>生成之后，打开博客根目录（D:\Myblog\blog）下的__config.yml，进行博客的配置。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271641408.png" alt="config配置1"></p><p>拉到最下面找到deploy，配置如下。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271728990.png" alt="deploy配置"></p><blockquote><p>type: git —-必须是git</p><p>repo：<a href="http://github.com/%E7%94%A8%E6%88%B7%E5%90%8D/%E7%94%A8%E6%88%B7%E5%90%8D.github.io.git">http://github.com/用户名/用户名.github.io.git</a>     # 用户名&#x2F;用户名.github.io  这个为刚刚创建的仓库。&#x3D;&#x3D;必须是这个格式&#x3D;&#x3D;   branch：master   </p></blockquote><p>配置好上面的步骤之后，需要在根目录下下载部署插件，在git中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h3><p>经过上面的步骤如果到此为止还没有出错的话那么恭喜你。这是最后一部。</p><p>在git中使用如下命令上传到github</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g #更新文件</span><br><span class="line">hexo d # 上传到服务器</span><br></pre></td></tr></table></figure><p>上面的指令没有问题的话可以在github仓库中看到本地的文件</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271735224.png" alt="github文件"></p><h1 id="开始搬砖"><a href="#开始搬砖" class="headerlink" title="开始搬砖"></a>开始搬砖</h1><h2 id="创建新的文章"><a href="#创建新的文章" class="headerlink" title="创建新的文章"></a>创建新的文章</h2><p>在git中输入<em><strong>hexo new “文章名”</strong></em>即可在source文件夹下的_posts文件夹看到生成的文章，这个文章只能支持markdown语法。</p><p>刚开始创建的文章头部为</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271739237.png" alt="文章头部"></p><p>我们可以根据之前的配置在文章头部加上如author，categories、tag标签。需要注意的是，标签与后面内容之间需要使用空格隔开，否则使用<strong>hexo g</strong>会报错。</p><p>文章头部还可以配置哪些功能可以参考作者的说明：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271742924.png" alt="文章配置说明"></p><p>写完文章后想要更新到github上还是按照上面的步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h1 id="关于上传时需要登陆的情况"><a href="#关于上传时需要登陆的情况" class="headerlink" title="关于上传时需要登陆的情况"></a>关于上传时需要登陆的情况</h1><p>有的时候在上传的时候会遇到要求登陆的情况，但是没办法使用用户名+密码的形式登录。这里需要使用Github中的token。</p><h2 id="github-token创建"><a href="#github-token创建" class="headerlink" title="github token创建"></a>github token创建</h2><p>在settings中拉到最下面找到Develop Settings，找到token</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271747757.png" alt="token创建"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271748418.png" alt="token创建2"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271750761.png" alt="token配置3"></p><p>拉到最下面确认生成token即可，token要记住，这个token只显示一次，后面不在显示。</p><p>在本地网站根目录下找到_config.yml并打开，拉到最下面的deploy中加入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token: 刚刚复制的token</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271753792.png" alt="token配置4"></p><h1 id="hexo-d上传超时解决办法"><a href="#hexo-d上传超时解决办法" class="headerlink" title="hexo d上传超时解决办法"></a>hexo d上传超时解决办法</h1><p>将配置项中的repo改成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo:git@github.com:/用户名/用户名.github.io.git</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂类技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
