<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FreeRTOS快速入门（一）</title>
      <link href="/2023/09/10/FreeRTOS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/09/10/FreeRTOS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要引入FreeRTOS"><a href="#为什么要引入FreeRTOS" class="headerlink" title="为什么要引入FreeRTOS"></a>为什么要引入FreeRTOS</h2><p>设想这样的场景，如果一个人需要打扫卫生，有需要写作业。这两件事的优先级是同样的。在裸机开发中面对这样的场景，如果是按照线性的方式进行程序编写如先写作业在打扫卫生或者是先打扫卫生，可能都会因为前面的任务执行的时间很长而耽误了另外一个任务的执行。（&#x3D;&#x3D;注：在裸机中减少任务运行时间的最好办法是使用状态机&#x3D;&#x3D;）。</p><p>那有没有能够“同时”执行这两种任务的方法呢？我们可以规定一个时间片，假设这个时间片是一秒，那么每隔一秒钟就切换一次任务，刚开始执行写作业的时候就开始计时，一秒钟一到就切换成打扫卫生。这样就能两个任务都将兼顾了。这就是FREERTOS的运行机制。在一些需要实时性比较强的系统中都会引入RTOS操作系统。</p><h2 id="FREERTOS结构分析及环境配置"><a href="#FREERTOS结构分析及环境配置" class="headerlink" title="FREERTOS结构分析及环境配置"></a>FREERTOS结构分析及环境配置</h2><p>FreeRTOS的下载地址：<a href="https://www.freertos.org/zh-cn-cmn-s/a00104.html">https://www.freertos.org/zh-cn-cmn-s/a00104.html</a></p><p>下载的时候&#x3D;&#x3D;不要&#x3D;&#x3D;选择LTS版本的，&#x3D;&#x3D;应该&#x3D;&#x3D;选择带有示例源码的版本。如下：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309101636002.png"></p><p>下载完解压后的目录如下：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309102225437.png"></p><p>目录中只有FreeRTOS需要用到，其他的文件可以删除。</p><p>进去FreeRTOS后里面的文件包含</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309102227921.png"></p><ul><li>Demo文件主要是示例代码</li><li>source文件时FreeRTOS的核心文件</li><li>其他的文件可以删除</li></ul><p>在Demo文件夹中包含了很多的示例程序，找到使用的IDE以及使用的芯片示例即可，其余的可以删除（根据编译报错，有时候需要留下Demo文件中的common文件夹。他是独立于Demo文件的独立文件）。</p><p>在source文件夹中，主要有一个protable文件夹，里面包含了移植文件时需要实现的参数函数。里面有各个IDE编译器的架构以及内存管理（MemMang）。留下需要的架构以及内存管理，剩下的可以删除。</p><p>MemMang文件夹中，包含heap_1\2\3\4\5，表示了5种不同的内存空间管理方法。</p><table><thead><tr><th>文件</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>heap_1</td><td>分配简单，时间确定</td><td>只分配、不回收</td></tr><tr><td>heap_2</td><td>动态分配、最佳匹配</td><td>碎片、时间不定</td></tr><tr><td>heap_3</td><td>调用标准库函数</td><td>速度慢、时间不定</td></tr><tr><td>heap_4</td><td>相邻空闲内存可合并</td><td>可解决碎片问题、时间不定</td></tr><tr><td>heap_5</td><td>在heap_4基础上支持分隔的内存块</td><td>可解决碎片问题、时间不定</td></tr></tbody></table><p>需要使用哪一种内存管理方式，只需要将相应的堆加载到程序中即可。</p><p>以下将使用keil-STM32F10x系列文件结构，将示例程序中示例代码进行删除和修改之后得到的结构如图所示：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309102242984.png"></p><p>使用示例程序修改好模板之后可以通过多次编译查找错误位置的方式将没用的程序删除。</p><h2 id="FreeRTOS基础说明"><a href="#FreeRTOS基础说明" class="headerlink" title="FreeRTOS基础说明"></a>FreeRTOS基础说明</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在FreeRTOS中定义了两个常见的数据类型分别是<code>TickType_t</code>以及<code>Base_type_t</code></p><blockquote><p><code>TickTtpe_t</code>可以是16位也可以是32位的，这取决于在FreeRTOS.h中是否定义<code>configUSE_16_BIT_TICKS  </code>如果定义了这个变量那么<code>TickTtpe_t</code>就是uint16_t类型，否则就是uint32_t类型</p><p><code>BaseType_t</code>是什么样的数据类型主要取决于MCU是什么样的架构，如果在32位架构中那么就是uint32_t，在16位架构中就是uint16_t，在8位架构中就是uint8_t。</p></blockquote><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><h4 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h4><p>FreeRTOS的变量名的是有规律的<code>变量名 = 前缀 + 含义</code></p><p>变量前缀：</p><table><thead><tr><th>前缀</th><th>含义</th></tr></thead><tbody><tr><td>x</td><td>Base_type_t 类型：结构体、任务句柄等等</td></tr><tr><td>c</td><td>char</td></tr><tr><td>s</td><td>int16_t</td></tr><tr><td>l</td><td>int32_t</td></tr><tr><td>u</td><td>unsigned</td></tr><tr><td>p</td><td>指针</td></tr><tr><td>uc</td><td>uint8_t</td></tr><tr><td>pc</td><td>char指针</td></tr></tbody></table><p>例如变量名：<code>xTaskToSuspend</code> 任务暂停变量，根据前缀x可以判断这个变量时Bse_type_t类型后面为变量的含义任务暂停</p><h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><p>函数名的命名规则主要是遵守：<code>函数名 = 返回类型+函数所在文件名+含义</code></p><p>例如创建任务的函数：xTaskCreate表示该函数的返回值为BaseType_t这个函数在Task.c文件中，作用是创建函数。</p><p><code>pvTimerGetTimerID</code>表示返回类型是void指针类型，在Timer文件中，作用是获取时间的ID</p><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><p>宏的名字可以在前面加上前缀表示这个宏在哪个文件中</p><table><thead><tr><th>宏前缀</th><th>文件</th></tr></thead><tbody><tr><td>port</td><td>portable.h</td></tr><tr><td>task</td><td>task.h</td></tr><tr><td>pd</td><td>projdefs.h</td></tr><tr><td>config</td><td>FreerRTOSConfig.h</td></tr><tr><td>err</td><td>projdefs.h</td></tr></tbody></table><p>例如：<code>portMAX_DELAY</code>表示这个宏在protable.h文件中</p><p><code>pdTRUE</code>表示这个宏在projdefs.h文件中。</p><p>通用的宏定义;</p><table><thead><tr><th>宏</th><th>含义</th></tr></thead><tbody><tr><td>pdTRUE</td><td>1</td></tr><tr><td>pdFALSE</td><td>0</td></tr><tr><td>pdPASS</td><td>1</td></tr><tr><td>pdFAIL</td><td>0</td></tr></tbody></table><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>在FreeRTOS中，任务就是函数，在执行任务时就是去执行创建任务时传入的函数指针。</p><p>在FreeRTOS中创建任务使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xTaskCreate(TaskFunction_t pxTaskCode,<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth,<span class="type">void</span> * <span class="type">const</span> pvParameters, UBaseType_t uxPriority, TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span><br></pre></td></tr></table></figure><table><thead><tr><th>变量</th><th>作用</th></tr></thead><tbody><tr><td>pxTaskCode</td><td>函数指针</td></tr><tr><td>pcName</td><td>任务名</td></tr><tr><td>usStackDepth</td><td>栈深度</td></tr><tr><td>pvParameters</td><td>传入函数的参数</td></tr><tr><td>uxPriority</td><td>任务的优先级</td></tr><tr><td>pxCreatedTask</td><td>任务句柄</td></tr></tbody></table><p>返回值：如果创建任务成功放回pdPass，任务创建失败返回errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY（-1）</p><p>创建失败的原因大部分是因为内存不足导致。</p><h4 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h4><p>优先级越高的任务优先执行，在FreeRTOS优先级取值范围为：0~(configMAX_PRIORITIES – 1)  ，值越高则任务优先级越高。</p><p>对于优先级相同的任务轮流执行。</p><h4 id="栈分配"><a href="#栈分配" class="headerlink" title="栈分配"></a>栈分配</h4><p>分配内存的时，在堆区会先创建一个头部，这个头部是一个至少包含了数据长度信息的结构体，并返回这个空间的首地址，在释放空间的时候首地址向前推得到数据的长度，从而确定需要释放的空间大小。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309241446349.png"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309241451834.png"></p><h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><p>删除任务使用的函数是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vTaskDelete(TaskHandle_t xTaskToDelete)</span><br></pre></td></tr></table></figure><p>删除任务的时候需要传入任务的句柄，任何任务都能够删除其他的任务，如果删除的任务传入的是NULL则表示任务自杀。</p><h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p>任务状态除了运行态以外，也有非运行态，但是非运行态也包含阻塞状态、暂停态、就绪态三种。</p><p>这三种非运行状态在不同场景下执行。</p><p>进入暂停状态可以是其他任务指定它为暂停状态也可以是自身进入暂停状态。但是如果要唤醒暂停状态的任务则需要别的任务进行唤醒或者是中断程序唤醒。</p><p>就绪状态是等待下一次运行的任务，他们不需要用函数调用和唤醒执行。等待时间片到达之后执行即可。</p><p>阻塞状态是被动进入状态的，在等待事件的时候不会消耗CPU，等到事件到来之后才被唤醒。这个事件可以是延迟函数、也可以是信号量，队列等等。</p><p>进入暂停状态使用VTasksuspend，但是如果要唤醒进入暂停的任务则需要其他任务执行vTaskResume来将任务唤醒。</p><p>三种状态的状态转换图如下：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202309171831581.png"></p><h3 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h3><p>在FreeRTOS中有两个常用的延迟函数：</p><p><code>vTaskDelay</code>等待指定时间之后任务从阻塞状态编程就绪状态</p><p><code>vTaskDelayUntil</code>等待绝对时长之后变成就绪状态</p><h3 id="空闲空间"><a href="#空闲空间" class="headerlink" title="空闲空间"></a>空闲空间</h3><p>空闲任务主要用于清理被删除的任务，释放空间。由于空闲任务的优先级为0，所以空闲任务不能进入阻塞和暂停状态，并且空闲任务执行的时间不能过长。</p><p>空闲任务在开启任务的时候就会自动调用空闲任务，如果我们需要在空闲任务中添加任务，不需要自己写空闲任务，在空闲任务中提供了一个钩子函数<code>vApplicationIdleHook  </code>。在使用这些函数的时候需要注意宏定义，有一些函数需要在定义宏之后才能使用，否则不能执行报错。调用钩子函数的时候不能使用while(1)以防空闲任务有其他的任务要做。</p><p><strong>由于空闲任务的优先级是0，空闲任务的优先级最低但是空闲任务确实很重要的，所以要保证空闲任务有执行的机会，如果其他二任务优先级都比空闲任务高并且这些任务都不进入阻塞或暂停状态，那么空闲任务将没有机会得到执行，那么删除任务之后被删除的任务的空间将得不到释放，在后续的执行中有可能空间不足导致系统奔溃。</strong></p><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>调度策略的配置一共有3中配置，一般是在FreeRTOSConfig.h文件中</p><blockquote><ol><li>可否抢占优先级（configUSE_PREEMPTION）<ol><li>可以抢占，则高优先级先执行</li><li>不可以，则高优先级不能抢占资源，只能能等待前面的任务执行完成之后才可以</li></ol></li><li>可以抢占优先级的前提下，同优先级是否支持时间片轮转（configUSE_TIME_SLICING）：<ol><li>支持时间片轮流：表示相同优先级的任务轮流执行，每个任务执行一个时间片</li><li>不支持时间片轮转：表示同个优先级的任务不能轮流执行，前面一个任务一直执行直到该任务主动放弃或高优先级抢占为止。</li></ol></li><li>在可以抢占优先级+支持时间片轮转的情况下空闲任务是否让步于用户任务（configIDLE_SHOULD_YIELD）：<ol><li>空闲任务主动让步于用户任务：表示在相同优先级的情况下空闲任务只有等到其他任务执行完成或者主动放弃执行为止空闲任务才能够执行</li><li>不让步于用户任务：则表示空闲任务会争夺相同优先级任务的执行权。</li></ol></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS快速入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用HEXO以及Github搭建博客</title>
      <link href="/2023/08/27/%E4%BD%BF%E7%94%A8HEXO%E4%BB%A5%E5%8F%8AGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/08/27/%E4%BD%BF%E7%94%A8HEXO%E4%BB%A5%E5%8F%8AGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="工欲善其事"><a href="#工欲善其事" class="headerlink" title="工欲善其事"></a>工欲善其事</h1><h2 id="Git下载及配置"><a href="#Git下载及配置" class="headerlink" title="Git下载及配置"></a>Git下载及配置</h2><p>电脑中需要安装git，没有git中可以在<a href="https://git-scm.com/downloads">官网</a>中下载。安装的时候一路next即可，也可以选择自己要安装的目录。</p><p>安装好git后，打开Git Bash(如图)</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271539904.png" alt="Git Bash"></p><p>然后使用以下git命令绑定账号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;github中的用户名&quot;</span><br><span class="line">git config --global user.emil &quot;github绑定的邮箱&quot;</span><br></pre></td></tr></table></figure><h2 id="Nose-JS下载"><a href="#Nose-JS下载" class="headerlink" title="Nose.JS下载"></a>Nose.JS下载</h2><p>hexo是基于Nose.js框架下驱动的，所以使用hexo创建网站的时候需要下载（Nose.js)[<a href="https://nodejs.org/en/download]%E6%A1%86%E6%9E%B6%E3%80%82">https://nodejs.org/en/download]框架。</a></p><p>以上步骤完成之后，可以使用<em>git -version</em>或者<em>npm -v</em>进行测试。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271553490.png" alt="测试下载"></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>在git中输入<em><strong>npm install -g hexo-cli</strong></em>下载hexo</p><h2 id="在github中创建静态网站的仓库"><a href="#在github中创建静态网站的仓库" class="headerlink" title="在github中创建静态网站的仓库"></a>在github中创建静态网站的仓库</h2><p>每一个账号都只能有一个repo个人主页，并且这个网站要放在maser分支上。在github中创建一个仓库，这个仓库的名字有严格的要求，格式为：&#x3D;&#x3D;用户名&#x2F;用户名.gothub.io&#x3D;&#x3D;，例如：xiaobini&#x2F;xiaobini.github.io，这里的用户名是Github的用户名，必须是Github用户名。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271607646.png" alt="仓库创建"></p><h1 id="利剑出鞘"><a href="#利剑出鞘" class="headerlink" title="利剑出鞘"></a>利剑出鞘</h1><h2 id="使用HEXO生成原始网站"><a href="#使用HEXO生成原始网站" class="headerlink" title="使用HEXO生成原始网站"></a>使用HEXO生成原始网站</h2><p>在任意位置右键打开Git Bash或者是使用cd指令进入，总之命令行要指向该窗口，我将博客的文件存放到D:\myblog中。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271625942.png"></p><p>然后在git中分别执行下面指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init blog  #这里的blog可以是你自己喜欢的名字</span><br><span class="line">cd blog</span><br><span class="line">nmp install</span><br></pre></td></tr></table></figure><p>如果上面指令都没有出错的话，可以输入 hexo s启动服务，然后在<a href="http://localhost:4000/">http://localhost:4000</a> 中可以看到该网站的最初形态。</p><h2 id="加载主题"><a href="#加载主题" class="headerlink" title="加载主题"></a>加载主题</h2><p>关于hexo中的各个主题可以在<a href="https://hexo.io/themes/index.html">hexo主题</a>中获得，下面就以<a href="https://github.com/blinkfox/hexo-theme-matery">matery</a>为例。</p><p>绝大多数主题作者都会告诉安装以及配置方式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/blinkfox/hexo-theme-matery.git # 使用该指令下载主题</span><br></pre></td></tr></table></figure><p>打开博客根目录（D:\Myblog\blog），找到_config.yml，打开后拉到最后找到theme。将landscpe替换成主题名字。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271759461.png" alt="主题配置1"></p><p>下载后将主题放置到hexo生成文件中的themes文件夹（D:\Myblog\blog\themes）中。这个时候在git中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 更新生成</span><br><span class="line">hexo s # 开启服务</span><br></pre></td></tr></table></figure><p>这个时候再打开<a href="http://localhost:4000/">http://localhost:4000</a> 就能看到主题。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>打开主题文件夹（D:\Myblog\blog\themes\hexo-theme-matery）找到_config.yml进行主题配置。</p><p>根据作者的描述，如果需要在网页中加上分类或者是标签的话需要在git中使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;tag&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271654345.png" alt="配置主题1"></p><p>输入后在博客目录的sorce文件夹下会分别生成tag、categories文件夹。这两个文件夹里面包含了index.md，打开后将头部修改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tag文件夹中的index.md加入</span></span><br><span class="line">title: tags</span><br><span class="line">date: 2018-09-30 18:23:38</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">categories文件夹中的index.md加入</span></span><br><span class="line">title: categories</span><br><span class="line">date: 2018-09-30 17:25:30</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271658498.png" alt="tag配置"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271700473.png" alt="categories配置"></p><p>以后在写文章的时候在文章的头部分别加入tag、categories就可以在网页中点击该栏目的时候看到这个文章。</p><p>关于其他的配置这里栏目的配置参照github中作者的配置。</p><p>自己需要的栏目配置好后，打开主题里面的__config.yml文件，进行配置。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271703854.png" alt="栏目配置"></p><p>关于其他的配置如音乐播放、背景图片、文字等等也都是在这个文档中进行配置，根据作者在这个文档中的注释进行配置。不在赘述。</p><p>配置好主题后重新输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 更新生成</span><br><span class="line">hexo s # 开启服务</span><br></pre></td></tr></table></figure><p>即可在<a href="http://localhost:4000/">http://localhost:4000</a> 查看网页配置的情况。</p><h2 id="博客部署到Github上"><a href="#博客部署到Github上" class="headerlink" title="博客部署到Github上"></a>博客部署到Github上</h2><h3 id="SSH-Key配置"><a href="#SSH-Key配置" class="headerlink" title="SSH Key配置"></a>SSH Key配置</h3><p>在git中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;</span><br><span class="line">ssh-keygen -t rsa -C &#x27;上面的邮箱&#x27;</span><br></pre></td></tr></table></figure><p>根据提示三次回车后生成ssh key。</p><p>之后再git中使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>查看ssh密钥，复制这个密钥打开github，在Settings中找到 SSH and GPG keys。点击Nnew SSH Key。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271719546.png" alt="github ssh配置"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271721704.png" alt="SSH 配置"></p><h3 id="根目录配置"><a href="#根目录配置" class="headerlink" title="根目录配置"></a>根目录配置</h3><p>生成之后，打开博客根目录（D:\Myblog\blog）下的__config.yml，进行博客的配置。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271641408.png" alt="config配置1"></p><p>拉到最下面找到deploy，配置如下。</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271728990.png" alt="deploy配置"></p><blockquote><p>type: git —-必须是git</p><p>repo：<a href="http://github.com/%E7%94%A8%E6%88%B7%E5%90%8D/%E7%94%A8%E6%88%B7%E5%90%8D.github.io.git">http://github.com/用户名/用户名.github.io.git</a>     # 用户名&#x2F;用户名.github.io  这个为刚刚创建的仓库。&#x3D;&#x3D;必须是这个格式&#x3D;&#x3D;   branch：master   </p></blockquote><p>配置好上面的步骤之后，需要在根目录下下载部署插件，在git中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h3><p>经过上面的步骤如果到此为止还没有出错的话那么恭喜你。这是最后一部。</p><p>在git中使用如下命令上传到github</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g #更新文件</span><br><span class="line">hexo d # 上传到服务器</span><br></pre></td></tr></table></figure><p>上面的指令没有问题的话可以在github仓库中看到本地的文件</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271735224.png" alt="github文件"></p><h1 id="开始搬砖"><a href="#开始搬砖" class="headerlink" title="开始搬砖"></a>开始搬砖</h1><h2 id="创建新的文章"><a href="#创建新的文章" class="headerlink" title="创建新的文章"></a>创建新的文章</h2><p>在git中输入<em><strong>hexo new “文章名”</strong></em>即可在source文件夹下的_posts文件夹看到生成的文章，这个文章只能支持markdown语法。</p><p>刚开始创建的文章头部为</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271739237.png" alt="文章头部"></p><p>我们可以根据之前的配置在文章头部加上如author，categories、tag标签。需要注意的是，标签与后面内容之间需要使用空格隔开，否则使用<strong>hexo g</strong>会报错。</p><p>文章头部还可以配置哪些功能可以参考作者的说明：</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271742924.png" alt="文章配置说明"></p><p>写完文章后想要更新到github上还是按照上面的步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h1 id="关于上传时需要登陆的情况"><a href="#关于上传时需要登陆的情况" class="headerlink" title="关于上传时需要登陆的情况"></a>关于上传时需要登陆的情况</h1><p>有的时候在上传的时候会遇到要求登陆的情况，但是没办法使用用户名+密码的形式登录。这里需要使用Github中的token。</p><h2 id="github-token创建"><a href="#github-token创建" class="headerlink" title="github token创建"></a>github token创建</h2><p>在settings中拉到最下面找到Develop Settings，找到token</p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271747757.png" alt="token创建"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271748418.png" alt="token创建2"></p><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271750761.png" alt="token配置3"></p><p>拉到最下面确认生成token即可，token要记住，这个token只显示一次，后面不在显示。</p><p>在本地网站根目录下找到_config.yml并打开，拉到最下面的deploy中加入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token: 刚刚复制的token</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xiaobini/image/main/image%5C202308271753792.png" alt="token配置4"></p><h1 id="hexo-d上传超时解决办法"><a href="#hexo-d上传超时解决办法" class="headerlink" title="hexo d上传超时解决办法"></a>hexo d上传超时解决办法</h1><p>将配置项中的repo改成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo:git@github.com:/用户名/用户名.github.io.git</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂类技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
